//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../fetch-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../fetch-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);

export type UpdateSlugQueryParameters = {
  id: string ;
}

export type UpdatePromptsQueryParameters = {
  id: string ;
}

export type UpdatePdfmeLayoutQueryParameters = {
  id: string ;
}

export type GetJurisdictionByIdQueryParameters = {
  id: string ;
}

export type UpdateJurisdictionQueryParameters = {
  id: string ;
}

export type DeleteJurisdictionQueryParameters = {
  id: string ;
}

export type UpdateDocumentStatusQueryParameters = {
  id: string ;
}

export type GetDealQueryParameters = {
  id: string ;
}

export type UpdateDealQueryParameters = {
  id: string ;
}

export type DeleteDealQueryParameters = {
  id: string ;
}

export type GetContractDataQueryParameters = {
  id: string ;
}

export type SaveContractDataQueryParameters = {
  id: string ;
}

export type HandleDocuSignEventQueryParameters = {
  x_DocuSign_Signature_1: string | undefined ;
}

export type HandleWebhookQueryParameters = {
  svix_id: string | undefined ;
  svix_timestamp: string | undefined ;
  svix_signature: string | undefined ;
}

export type PublishQueryParameters = {
  id: string ;
}




export type ListGuestCounterOffersQueryParameters = {
  x_Guest_Token: string ;
}

export type CreateGuestCounterOfferQueryParameters = {
  x_Guest_Token: string ;
}

export type UploadGuestCounterOfferPdfQueryParameters = {
  x_Guest_Token: string ;
  id: string ;
}

export type SendForSignatureQueryParameters = {
  documentId: string ;
}

export type SendEmailQueryParameters = {
  documentId: string ;
}

export type ListDocumentsQueryParameters = {
  dealId: string ;
}

export type CreateDocumentQueryParameters = {
  dealId: string ;
}

export type ListDealsQueryParameters = {
  status: string | undefined ;
  search: string | undefined ;
  limit: number | undefined ;
  offset: number | undefined ;
  docType: string | undefined ;
}

export type ListGuestLinksQueryParameters = {
  id: string ;
}

export type CreateGuestLinkQueryParameters = {
  id: string ;
}

export type ListCounterOffersQueryParameters = {
  id: string ;
}

export type CreateCounterOfferQueryParameters = {
  id: string ;
}

export type UploadCounterOfferPdfQueryParameters = {
  id: string ;
}

export type GetCounterOfferQueryParameters = {
  id: string ;
}

export type DeleteCounterOfferQueryParameters = {
  id: string ;
}

export type UpdateCounterOfferQueryParameters = {
  id: string ;
}

export type GetTemplateVersionByIdQueryParameters = {
  id: string ;
  status: Types.Status ;
}

export type GetTemplatePdfmeLayoutQueryParameters = {
  id: string ;
  status: Types.Status2 ;
}

export type GetAllTemplateVersionsQueryParameters = {
  status: Types.Status3 ;
}

export type FindOrCreateTemplateQueryParameters = {
  jurisdictionCode: string ;
  templateType: Types.TemplateType ;
  slug: string | undefined ;
}

export type GetAddendumPdfmeLayoutQueryParameters = {
  addendumSlug: string ;
  userId: string | undefined ;
  status: Types.Status4 | undefined ;
}

export type MatchAddressQueryParameters = {
  postalCode: string ;
  streetNumber: string ;
  premisesAddress: string ;
}

export type GetItemByIdQueryParameters = {
  mlsId: string ;
}

export type GetTemplatesQueryParameters = {
  code: string ;
  templateType: Types.TemplateType2 | undefined ;
}

export type GetMlsFieldsQueryParameters = {
  code: string ;
}

export type GetMlsFieldStructureQueryParameters = {
  code: string ;
  fieldName: string ;
}

export type GetGuestCounterOfferQueryParameters = {
  x_Guest_Token: string ;
  id: string ;
}

export type GetGuestContractViewQueryParameters = {
  x_Guest_Token: string ;
}

export type GetExtractionsQueryParameters = {
  userId: string | undefined ;
  callId: string | undefined ;
}

export type GetLatestExtractionQueryParameters = {
  userId: string | undefined ;
}

export type GetDocumentQueryParameters = {
  id: string ;
}

export type GetContractsByAgentQueryParameters = {
  userId: string ;
}

export type GetPdfmeLayoutQueryParameters = {
  id: string ;
}

export type GetAddendaQueryParameters = {
  id: string ;
}

export type DeleteTemplateQueryParameters = {
  id: string ;
}

export type RevokeGuestLinkQueryParameters = {
  linkId: string ;
}

export type DeleteDocumentQueryParameters = {
  id: string ;
}

export function updateSlugUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}/slug";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateSlugMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateSlug',
      id as any,
    ]);
}

/**
 * Update template slug
 * @param id Template ID
 * @return OK
 */
export function useUpdateSlugMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.TemplateSlugUpdateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.TemplateSlugUpdateRequest, TContext> {
  const key = updateSlugMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.TemplateSlugUpdateRequest) => Client().updateSlug(id, body),
    mutationKey: key,
  });
}
  
type UpdateSlug__MutationParameters = UpdateSlugQueryParameters & {
  body: Types.TemplateSlugUpdateRequest;
}

/**
 * Update template slug
 * @param id Template ID
 * @return OK
 */
export function useUpdateSlugMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UpdateSlug__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateSlugQueryParameters}): UseMutationResult<void, unknown, UpdateSlug__MutationParameters, TContext> {
  const key = updateSlugMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateSlug__MutationParameters) => Client().updateSlug(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function updatePromptsUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}/prompts";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePromptsMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updatePrompts',
      id as any,
    ]);
}

/**
 * Update prompts for the latest DRAFT version
 * @return OK
 */
export function useUpdatePromptsMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.ContractTemplateUpdateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.ContractTemplateUpdateRequest, TContext> {
  const key = updatePromptsMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ContractTemplateUpdateRequest) => Client().updatePrompts(id, body),
    mutationKey: key,
  });
}
  
type UpdatePrompts__MutationParameters = UpdatePromptsQueryParameters & {
  body: Types.ContractTemplateUpdateRequest;
}

/**
 * Update prompts for the latest DRAFT version
 * @return OK
 */
export function useUpdatePromptsMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UpdatePrompts__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdatePromptsQueryParameters}): UseMutationResult<void, unknown, UpdatePrompts__MutationParameters, TContext> {
  const key = updatePromptsMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdatePrompts__MutationParameters) => Client().updatePrompts(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function updatePdfmeLayoutUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}/pdfme-layout";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePdfmeLayoutMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updatePdfmeLayout',
      id as any,
    ]);
}

/**
 * Update PDFME layout
 * @param id Template ID
 * @return OK
 */
export function useUpdatePdfmeLayoutMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.PdfmeLayoutUpdateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.PdfmeLayoutUpdateRequest, TContext> {
  const key = updatePdfmeLayoutMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.PdfmeLayoutUpdateRequest) => Client().updatePdfmeLayout(id, body),
    mutationKey: key,
  });
}
  
type UpdatePdfmeLayout__MutationParameters = UpdatePdfmeLayoutQueryParameters & {
  body: Types.PdfmeLayoutUpdateRequest;
}

/**
 * Update PDFME layout
 * @param id Template ID
 * @return OK
 */
export function useUpdatePdfmeLayoutMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UpdatePdfmeLayout__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdatePdfmeLayoutQueryParameters}): UseMutationResult<void, unknown, UpdatePdfmeLayout__MutationParameters, TContext> {
  const key = updatePdfmeLayoutMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdatePdfmeLayout__MutationParameters) => Client().updatePdfmeLayout(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function getCurrentUserProfileUrl(): string {
  let url_ = getBaseUrl() + "/v1/profile/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getCurrentUserProfileDefaultOptions: Omit<UseQueryOptions<Types.UserResponseDTO, unknown, Types.UserResponseDTO>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.UserResponseDTO, unknown, Types.UserResponseDTO>, 'queryFn'>> = {
};
export function getGetCurrentUserProfileDefaultOptions() {
  return getCurrentUserProfileDefaultOptions;
};
export function setGetCurrentUserProfileDefaultOptions(options: typeof getCurrentUserProfileDefaultOptions) {
  getCurrentUserProfileDefaultOptions = options;
}

export function getCurrentUserProfileQueryKey(): QueryKey;
export function getCurrentUserProfileQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getCurrentUserProfile',
    ]);
}
export function __getCurrentUserProfile(context: QueryFunctionContext) {
  return Client().getCurrentUserProfile(
    );
}

/**
 * Get current user profile
 * @return OK
 */
export function useGetCurrentUserProfileQuery<TSelectData = Types.UserResponseDTO, TError = unknown>(options?: Omit<UseQueryOptions<Types.UserResponseDTO, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetCurrentUserProfileQuery<TSelectData = Types.UserResponseDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserResponseDTO, TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.UserResponseDTO, TError, TSelectData>({
    queryFn: __getCurrentUserProfile,
    queryKey: getCurrentUserProfileQueryKey(),
    ...getCurrentUserProfileDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserResponseDTO, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get current user profile
 * @return OK
 */
export function setGetCurrentUserProfileData(queryClient: QueryClient, updater: (data: Types.UserResponseDTO | undefined) => Types.UserResponseDTO, ) {
  queryClient.setQueryData(getCurrentUserProfileQueryKey(),
    updater
  );
}

/**
 * Get current user profile
 * @return OK
 */
export function setGetCurrentUserProfileDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserResponseDTO | undefined) => Types.UserResponseDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateCurrentUserProfileUrl(): string {
  let url_ = getBaseUrl() + "/v1/profile/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateCurrentUserProfileMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateCurrentUserProfile',
    ]);
}

/**
 * Update user profile
 * @return OK
 */
export function useUpdateCurrentUserProfileMutation<TContext>(options?: Omit<UseMutationOptions<Types.UserResponseDTO, unknown, Types.OnboardingRequestDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserResponseDTO, unknown, Types.OnboardingRequestDTO, TContext> {
  const key = updateCurrentUserProfileMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.OnboardingRequestDTO) => Client().updateCurrentUserProfile(body),
    mutationKey: key,
  });
}
  
export function getJurisdictionByIdUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getJurisdictionByIdDefaultOptions: Omit<UseQueryOptions<Types.JurisdictionResponseDto, unknown, Types.JurisdictionResponseDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.JurisdictionResponseDto, unknown, Types.JurisdictionResponseDto>, 'queryFn'>> = {
};
export function getGetJurisdictionByIdDefaultOptions() {
  return getJurisdictionByIdDefaultOptions;
};
export function setGetJurisdictionByIdDefaultOptions(options: typeof getJurisdictionByIdDefaultOptions) {
  getJurisdictionByIdDefaultOptions = options;
}

export function getJurisdictionByIdQueryKey(id: string): QueryKey;
export function getJurisdictionByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetJurisdictionByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getJurisdictionById',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getJurisdictionById',
        ...params
      ]);
  }
}
export function __getJurisdictionById(context: QueryFunctionContext) {
  return Client().getJurisdictionById(
      context.queryKey[2] as string    );
}

export function useGetJurisdictionByIdQuery<TSelectData = Types.JurisdictionResponseDto, TError = unknown>(dto: GetJurisdictionByIdQueryParameters, options?: Omit<UseQueryOptions<Types.JurisdictionResponseDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get a jurisdiction by ID
 * @return Jurisdiction retrieved
 */
export function useGetJurisdictionByIdQuery<TSelectData = Types.JurisdictionResponseDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.JurisdictionResponseDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetJurisdictionByIdQuery<TSelectData = Types.JurisdictionResponseDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.JurisdictionResponseDto, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetJurisdictionByIdQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.JurisdictionResponseDto, TError, TSelectData>({
    queryFn: __getJurisdictionById,
    queryKey: getJurisdictionByIdQueryKey(id),
    ...getJurisdictionByIdDefaultOptions as unknown as Omit<UseQueryOptions<Types.JurisdictionResponseDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get a jurisdiction by ID
 * @return Jurisdiction retrieved
 */
export function setGetJurisdictionByIdData(queryClient: QueryClient, updater: (data: Types.JurisdictionResponseDto | undefined) => Types.JurisdictionResponseDto, id: string) {
  queryClient.setQueryData(getJurisdictionByIdQueryKey(id),
    updater
  );
}

/**
 * Get a jurisdiction by ID
 * @return Jurisdiction retrieved
 */
export function setGetJurisdictionByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.JurisdictionResponseDto | undefined) => Types.JurisdictionResponseDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateJurisdictionUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateJurisdictionMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateJurisdiction',
      id as any,
    ]);
}

/**
 * Update a jurisdiction
 * @return Jurisdiction updated
 */
export function useUpdateJurisdictionMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.JurisdictionResponseDto, unknown, Types.JurisdictionRequestDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.JurisdictionResponseDto, unknown, Types.JurisdictionRequestDto, TContext> {
  const key = updateJurisdictionMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.JurisdictionRequestDto) => Client().updateJurisdiction(id, body),
    mutationKey: key,
  });
}
  
type UpdateJurisdiction__MutationParameters = UpdateJurisdictionQueryParameters & {
  body: Types.JurisdictionRequestDto;
}

/**
 * Update a jurisdiction
 * @return Jurisdiction updated
 */
export function useUpdateJurisdictionMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.JurisdictionResponseDto, unknown, UpdateJurisdiction__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateJurisdictionQueryParameters}): UseMutationResult<Types.JurisdictionResponseDto, unknown, UpdateJurisdiction__MutationParameters, TContext> {
  const key = updateJurisdictionMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateJurisdiction__MutationParameters) => Client().updateJurisdiction(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function deleteJurisdictionUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteJurisdictionMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteJurisdiction',
      id as any,
    ]);
}

/**
 * Delete a jurisdiction (soft delete)
 * @return Jurisdiction soft deleted
 */
export function useDeleteJurisdictionMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteJurisdictionMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteJurisdiction(id),
    mutationKey: key,
  });
}
  
type DeleteJurisdiction__MutationParameters = DeleteJurisdictionQueryParameters

/**
 * Delete a jurisdiction (soft delete)
 * @return Jurisdiction soft deleted
 */
export function useDeleteJurisdictionMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteJurisdiction__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteJurisdictionQueryParameters}): UseMutationResult<void, unknown, DeleteJurisdiction__MutationParameters, TContext> {
  const key = deleteJurisdictionMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteJurisdiction__MutationParameters) => Client().deleteJurisdiction(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function updateDocumentStatusUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/documents/{id}/status";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateDocumentStatusMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateDocumentStatus',
      id as any,
    ]);
}

/**
 * Update document status
 * @param id Document ID
 * @return OK
 */
export function useUpdateDocumentStatusMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.DocumentStatusUpdateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.DocumentStatusUpdateRequest, TContext> {
  const key = updateDocumentStatusMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DocumentStatusUpdateRequest) => Client().updateDocumentStatus(id, body),
    mutationKey: key,
  });
}
  
type UpdateDocumentStatus__MutationParameters = UpdateDocumentStatusQueryParameters & {
  body: Types.DocumentStatusUpdateRequest;
}

/**
 * Update document status
 * @param id Document ID
 * @return OK
 */
export function useUpdateDocumentStatusMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UpdateDocumentStatus__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateDocumentStatusQueryParameters}): UseMutationResult<void, unknown, UpdateDocumentStatus__MutationParameters, TContext> {
  const key = updateDocumentStatusMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateDocumentStatus__MutationParameters) => Client().updateDocumentStatus(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function getDealUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getDealDefaultOptions: Omit<UseQueryOptions<Types.DealDetailDto, unknown, Types.DealDetailDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DealDetailDto, unknown, Types.DealDetailDto>, 'queryFn'>> = {
};
export function getGetDealDefaultOptions() {
  return getDealDefaultOptions;
};
export function setGetDealDefaultOptions(options: typeof getDealDefaultOptions) {
  getDealDefaultOptions = options;
}

export function getDealQueryKey(id: string): QueryKey;
export function getDealQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetDealQueryParameters;

    return trimArrayEnd([
        'Client',
        'getDeal',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getDeal',
        ...params
      ]);
  }
}
export function __getDeal(context: QueryFunctionContext) {
  return Client().getDeal(
      context.queryKey[2] as string    );
}

export function useGetDealQuery<TSelectData = Types.DealDetailDto, TError = unknown>(dto: GetDealQueryParameters, options?: Omit<UseQueryOptions<Types.DealDetailDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get deal details
 * @param id Deal ID
 * @return OK
 */
export function useGetDealQuery<TSelectData = Types.DealDetailDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.DealDetailDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetDealQuery<TSelectData = Types.DealDetailDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DealDetailDto, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetDealQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DealDetailDto, TError, TSelectData>({
    queryFn: __getDeal,
    queryKey: getDealQueryKey(id),
    ...getDealDefaultOptions as unknown as Omit<UseQueryOptions<Types.DealDetailDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get deal details
 * @param id Deal ID
 * @return OK
 */
export function setGetDealData(queryClient: QueryClient, updater: (data: Types.DealDetailDto | undefined) => Types.DealDetailDto, id: string) {
  queryClient.setQueryData(getDealQueryKey(id),
    updater
  );
}

/**
 * Get deal details
 * @param id Deal ID
 * @return OK
 */
export function setGetDealDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DealDetailDto | undefined) => Types.DealDetailDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateDealUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateDealMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateDeal',
      id as any,
    ]);
}

/**
 * Update a deal
 * @param id Deal ID
 * @return OK
 */
export function useUpdateDealMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.DealDetailDto, unknown, Types.DealUpdateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DealDetailDto, unknown, Types.DealUpdateRequest, TContext> {
  const key = updateDealMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DealUpdateRequest) => Client().updateDeal(id, body),
    mutationKey: key,
  });
}
  
type UpdateDeal__MutationParameters = UpdateDealQueryParameters & {
  body: Types.DealUpdateRequest;
}

/**
 * Update a deal
 * @param id Deal ID
 * @return OK
 */
export function useUpdateDealMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DealDetailDto, unknown, UpdateDeal__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateDealQueryParameters}): UseMutationResult<Types.DealDetailDto, unknown, UpdateDeal__MutationParameters, TContext> {
  const key = updateDealMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateDeal__MutationParameters) => Client().updateDeal(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function deleteDealUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteDealMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteDeal',
      id as any,
    ]);
}

/**
 * Delete a deal (soft delete)
 * @param id Deal ID
 * @return OK
 */
export function useDeleteDealMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteDealMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteDeal(id),
    mutationKey: key,
  });
}
  
type DeleteDeal__MutationParameters = DeleteDealQueryParameters

/**
 * Delete a deal (soft delete)
 * @param id Deal ID
 * @return OK
 */
export function useDeleteDealMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteDeal__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteDealQueryParameters}): UseMutationResult<void, unknown, DeleteDeal__MutationParameters, TContext> {
  const key = deleteDealMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteDeal__MutationParameters) => Client().deleteDeal(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function getContractDataUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/contract-data";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getContractDataDefaultOptions: Omit<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryFn'>> = {
};
export function getGetContractDataDefaultOptions() {
  return getContractDataDefaultOptions;
};
export function setGetContractDataDefaultOptions(options: typeof getContractDataDefaultOptions) {
  getContractDataDefaultOptions = options;
}

export function getContractDataQueryKey(id: string): QueryKey;
export function getContractDataQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetContractDataQueryParameters;

    return trimArrayEnd([
        'Client',
        'getContractData',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getContractData',
        ...params
      ]);
  }
}
export function __getContractData(context: QueryFunctionContext) {
  return Client().getContractData(
      context.queryKey[2] as string    );
}

export function useGetContractDataQuery<TSelectData = Types.FileResponse, TError = unknown>(dto: GetContractDataQueryParameters, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get contract data for deal
 * @param id Deal ID
 * @return OK
 */
export function useGetContractDataQuery<TSelectData = Types.FileResponse, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetContractDataQuery<TSelectData = Types.FileResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileResponse, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetContractDataQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FileResponse, TError, TSelectData>({
    queryFn: __getContractData,
    queryKey: getContractDataQueryKey(id),
    ...getContractDataDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get contract data for deal
 * @param id Deal ID
 * @return OK
 */
export function setGetContractDataData(queryClient: QueryClient, updater: (data: Types.FileResponse | undefined) => Types.FileResponse, id: string) {
  queryClient.setQueryData(getContractDataQueryKey(id),
    updater
  );
}

/**
 * Get contract data for deal
 * @param id Deal ID
 * @return OK
 */
export function setGetContractDataDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileResponse | undefined) => Types.FileResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function saveContractDataUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/contract-data";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function saveContractDataMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'saveContractData',
      id as any,
    ]);
}

/**
 * Save contract data for deal
 * @param id Deal ID
 * @return OK
 */
export function useSaveContractDataMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.JsonNode, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.JsonNode, TContext> {
  const key = saveContractDataMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.JsonNode) => Client().saveContractData(id, body),
    mutationKey: key,
  });
}
  
type SaveContractData__MutationParameters = SaveContractDataQueryParameters & {
  body: Types.JsonNode;
}

/**
 * Save contract data for deal
 * @param id Deal ID
 * @return OK
 */
export function useSaveContractDataMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, SaveContractData__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SaveContractDataQueryParameters}): UseMutationResult<void, unknown, SaveContractData__MutationParameters, TContext> {
  const key = saveContractDataMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SaveContractData__MutationParameters) => Client().saveContractData(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function handleRetellWebhookUrl(): string {
  let url_ = getBaseUrl() + "/v1/webhooks/retell";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleRetellWebhookMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleRetellWebhook',
    ]);
}

/**
 * Process Retell webhook
 * @return OK
 */
export function useHandleRetellWebhookMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, string, TContext> {
  const key = handleRetellWebhookMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client().handleRetellWebhook(body),
    mutationKey: key,
  });
}
  
export function handleDocuSignEventUrl(x_DocuSign_Signature_1: string | undefined): string {
  let url_ = getBaseUrl() + "/v1/webhooks/docusign";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDocuSignEventMutationKey(x_DocuSign_Signature_1: string | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDocuSignEvent',
      x_DocuSign_Signature_1 as any,
    ]);
}

/**
 * Process DocuSign webhook
 * @param x_DocuSign_Signature_1 (optional) 
 * @return OK
 */
export function useHandleDocuSignEventMutation<TContext>(x_DocuSign_Signature_1: string | undefined, options?: Omit<UseMutationOptions<void, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, string, TContext> {
  const key = handleDocuSignEventMutationKey(x_DocuSign_Signature_1);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client().handleDocuSignEvent(x_DocuSign_Signature_1, body),
    mutationKey: key,
  });
}
  
type HandleDocuSignEvent__MutationParameters = HandleDocuSignEventQueryParameters & {
  body: string;
}

/**
 * Process DocuSign webhook
 * @param x_DocuSign_Signature_1 (optional) 
 * @return OK
 */
export function useHandleDocuSignEventMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandleDocuSignEvent__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDocuSignEventQueryParameters}): UseMutationResult<void, unknown, HandleDocuSignEvent__MutationParameters, TContext> {
  const key = handleDocuSignEventMutationKey(options?.parameters?.x_DocuSign_Signature_1!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDocuSignEvent__MutationParameters) => Client().handleDocuSignEvent(data.x_DocuSign_Signature_1 ?? options?.parameters?.x_DocuSign_Signature_1!, data.body),
  mutationKey: key,
});
}
  
export function handleWebhookUrl(svix_id: string | undefined, svix_timestamp: string | undefined, svix_signature: string | undefined): string {
  let url_ = getBaseUrl() + "/v1/webhooks/clerk";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleWebhookMutationKey(svix_id: string | undefined, svix_timestamp: string | undefined, svix_signature: string | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleWebhook',
      svix_id as any,
      svix_timestamp as any,
      svix_signature as any,
    ]);
}

/**
 * @param svix_id (optional) 
 * @param svix_timestamp (optional) 
 * @param svix_signature (optional) 
 * @return OK
 */
export function useHandleWebhookMutation<TContext>(svix_id: string | undefined, svix_timestamp: string | undefined, svix_signature: string | undefined, options?: Omit<UseMutationOptions<string, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, string, TContext> {
  const key = handleWebhookMutationKey(svix_id, svix_timestamp, svix_signature);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client().handleWebhook(svix_id, svix_timestamp, svix_signature, body),
    mutationKey: key,
  });
}
  
type HandleWebhook__MutationParameters = HandleWebhookQueryParameters & {
  body: string;
}

/**
 * @param svix_id (optional) 
 * @param svix_timestamp (optional) 
 * @param svix_signature (optional) 
 * @return OK
 */
export function useHandleWebhookMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<string, unknown, HandleWebhook__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleWebhookQueryParameters}): UseMutationResult<string, unknown, HandleWebhook__MutationParameters, TContext> {
  const key = handleWebhookMutationKey(options?.parameters?.svix_id!, options?.parameters?.svix_timestamp!, options?.parameters?.svix_signature!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleWebhook__MutationParameters) => Client().handleWebhook(data.svix_id ?? options?.parameters?.svix_id!, data.svix_timestamp ?? options?.parameters?.svix_timestamp!, data.svix_signature ?? options?.parameters?.svix_signature!, data.body),
  mutationKey: key,
});
}
  
export function createUrl(): string {
  let url_ = getBaseUrl() + "/v1/templates";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'create',
    ]);
}

/**
 * Create a new contract template
 * @return OK
 */
export function useCreateMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, Types.ContractTemplateCreateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.ContractTemplateCreateRequest, TContext> {
  const key = createMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ContractTemplateCreateRequest) => Client().create(body),
    mutationKey: key,
  });
}
  
export function publishUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}/publish";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function publishMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'publish',
      id as any,
    ]);
}

/**
 * Publish template version
 * @return OK
 */
export function usePublishMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = publishMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().publish(id),
    mutationKey: key,
  });
}
  
type Publish__MutationParameters = PublishQueryParameters

/**
 * Publish template version
 * @return OK
 */
export function usePublishMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, Publish__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: PublishQueryParameters}): UseMutationResult<void, unknown, Publish__MutationParameters, TContext> {
  const key = publishMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Publish__MutationParameters) => Client().publish(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function regenerateAllPromptsUrl(): string {
  let url_ = getBaseUrl() + "/v1/templates/regenerate-prompts";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function regenerateAllPromptsMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'regenerateAllPrompts',
    ]);
}

/**
 * Regenerate all prompts
 * @return OK
 */
export function useRegenerateAllPromptsMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, void, TContext> {
  const key = regenerateAllPromptsMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().regenerateAllPrompts(),
    mutationKey: key,
  });
}
  
export function initPromptUrl(): string {
  let url_ = getBaseUrl() + "/v1/prompt-init";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function initPromptMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'initPrompt',
    ]);
}

/**
 * Initialize prompt
 * @return OK
 */
export function useInitPromptMutation<TContext>(options?: Omit<UseMutationOptions<Types.PromptInitResponse, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PromptInitResponse, unknown, string, TContext> {
  const key = initPromptMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client().initPrompt(body),
    mutationKey: key,
  });
}
  
export function initExtractionPromptUrl(): string {
  let url_ = getBaseUrl() + "/v1/prompt-extraction";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function initExtractionPromptMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'initExtractionPrompt',
    ]);
}

/**
 * Initialize extraction prompt
 * @return OK
 */
export function useInitExtractionPromptMutation<TContext>(options?: Omit<UseMutationOptions<Types.PromptInitResponse, unknown, Types.PromptInitRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PromptInitResponse, unknown, Types.PromptInitRequest, TContext> {
  const key = initExtractionPromptMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.PromptInitRequest) => Client().initExtractionPrompt(body),
    mutationKey: key,
  });
}
  
export function completeOnboardingUrl(): string {
  let url_ = getBaseUrl() + "/v1/onboarding";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function completeOnboardingMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'completeOnboarding',
    ]);
}

/**
 * Complete agent onboarding
 * @return OK
 */
export function useCompleteOnboardingMutation<TContext>(options?: Omit<UseMutationOptions<Types.UserResponseDTO, unknown, Types.OnboardingRequestDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserResponseDTO, unknown, Types.OnboardingRequestDTO, TContext> {
  const key = completeOnboardingMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.OnboardingRequestDTO) => Client().completeOnboarding(body),
    mutationKey: key,
  });
}
  
export function getAllJurisdictionsUrl(): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAllJurisdictionsDefaultOptions: Omit<UseQueryOptions<Types.JurisdictionResponseDto[], unknown, Types.JurisdictionResponseDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.JurisdictionResponseDto[], unknown, Types.JurisdictionResponseDto[]>, 'queryFn'>> = {
};
export function getGetAllJurisdictionsDefaultOptions() {
  return getAllJurisdictionsDefaultOptions;
};
export function setGetAllJurisdictionsDefaultOptions(options: typeof getAllJurisdictionsDefaultOptions) {
  getAllJurisdictionsDefaultOptions = options;
}

export function getAllJurisdictionsQueryKey(): QueryKey;
export function getAllJurisdictionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getAllJurisdictions',
    ]);
}
export function __getAllJurisdictions(context: QueryFunctionContext) {
  return Client().getAllJurisdictions(
    );
}

/**
 * Get all active jurisdictions
 * @return List of jurisdictions retrieved successfully
 */
export function useGetAllJurisdictionsQuery<TSelectData = Types.JurisdictionResponseDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.JurisdictionResponseDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetAllJurisdictionsQuery<TSelectData = Types.JurisdictionResponseDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.JurisdictionResponseDto[], TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.JurisdictionResponseDto[], TError, TSelectData>({
    queryFn: __getAllJurisdictions,
    queryKey: getAllJurisdictionsQueryKey(),
    ...getAllJurisdictionsDefaultOptions as unknown as Omit<UseQueryOptions<Types.JurisdictionResponseDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get all active jurisdictions
 * @return List of jurisdictions retrieved successfully
 */
export function setGetAllJurisdictionsData(queryClient: QueryClient, updater: (data: Types.JurisdictionResponseDto[] | undefined) => Types.JurisdictionResponseDto[], ) {
  queryClient.setQueryData(getAllJurisdictionsQueryKey(),
    updater
  );
}

/**
 * Get all active jurisdictions
 * @return List of jurisdictions retrieved successfully
 */
export function setGetAllJurisdictionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.JurisdictionResponseDto[] | undefined) => Types.JurisdictionResponseDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createJurisdictionUrl(): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createJurisdictionMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createJurisdiction',
    ]);
}

/**
 * Create a new jurisdiction
 * @return Jurisdiction created
 */
export function useCreateJurisdictionMutation<TContext>(options?: Omit<UseMutationOptions<Types.JurisdictionResponseDto, unknown, Types.JurisdictionRequestDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.JurisdictionResponseDto, unknown, Types.JurisdictionRequestDto, TContext> {
  const key = createJurisdictionMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.JurisdictionRequestDto) => Client().createJurisdiction(body),
    mutationKey: key,
  });
}
  
export function handleInstanceWebhookUrl(): string {
  let url_ = getBaseUrl() + "/v1/instance-webhook";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleInstanceWebhookMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleInstanceWebhook',
    ]);
}

/**
 * Process Retell instance webhook
 * @return OK
 */
export function useHandleInstanceWebhookMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, string, TContext> {
  const key = handleInstanceWebhookMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client().handleInstanceWebhook(body),
    mutationKey: key,
  });
}
  
export function validateGuestTokenUrl(): string {
  let url_ = getBaseUrl() + "/v1/guest/validate";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function validateGuestTokenMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'validateGuestToken',
    ]);
}

/**
 * Validate guest token
 * @return OK
 */
export function useValidateGuestTokenMutation<TContext>(options?: Omit<UseMutationOptions<Types.GuestLinkDto, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.GuestLinkDto, unknown, string, TContext> {
  const key = validateGuestTokenMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client().validateGuestToken(body),
    mutationKey: key,
  });
}
  
export function listGuestCounterOffersUrl(x_Guest_Token: string): string {
  let url_ = getBaseUrl() + "/v1/guest/counteroffers";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let listGuestCounterOffersDefaultOptions: Omit<UseQueryOptions<Types.CounterOfferDto[], unknown, Types.CounterOfferDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CounterOfferDto[], unknown, Types.CounterOfferDto[]>, 'queryFn'>> = {
};
export function getListGuestCounterOffersDefaultOptions() {
  return listGuestCounterOffersDefaultOptions;
};
export function setListGuestCounterOffersDefaultOptions(options: typeof listGuestCounterOffersDefaultOptions) {
  listGuestCounterOffersDefaultOptions = options;
}

export function listGuestCounterOffersQueryKey(x_Guest_Token: string): QueryKey;
export function listGuestCounterOffersQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { x_Guest_Token,  } = params[0] as ListGuestCounterOffersQueryParameters;

    return trimArrayEnd([
        'Client',
        'listGuestCounterOffers',
        x_Guest_Token as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'listGuestCounterOffers',
        ...params
      ]);
  }
}
export function __listGuestCounterOffers(context: QueryFunctionContext) {
  return Client().listGuestCounterOffers(
      context.queryKey[2] as string    );
}

export function useListGuestCounterOffersQuery<TSelectData = Types.CounterOfferDto[], TError = unknown>(dto: ListGuestCounterOffersQueryParameters, options?: Omit<UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List counter offers as guest
 * @return OK
 */
export function useListGuestCounterOffersQuery<TSelectData = Types.CounterOfferDto[], TError = unknown>(x_Guest_Token: string, options?: Omit<UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useListGuestCounterOffersQuery<TSelectData = Types.CounterOfferDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData> | undefined = undefined;
  let x_Guest_Token: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ x_Guest_Token,  } = params[0] as ListGuestCounterOffersQueryParameters);
      options = params[1];
    } else {
      [x_Guest_Token, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CounterOfferDto[], TError, TSelectData>({
    queryFn: __listGuestCounterOffers,
    queryKey: listGuestCounterOffersQueryKey(x_Guest_Token),
    ...listGuestCounterOffersDefaultOptions as unknown as Omit<UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List counter offers as guest
 * @return OK
 */
export function setListGuestCounterOffersData(queryClient: QueryClient, updater: (data: Types.CounterOfferDto[] | undefined) => Types.CounterOfferDto[], x_Guest_Token: string) {
  queryClient.setQueryData(listGuestCounterOffersQueryKey(x_Guest_Token),
    updater
  );
}

/**
 * List counter offers as guest
 * @return OK
 */
export function setListGuestCounterOffersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CounterOfferDto[] | undefined) => Types.CounterOfferDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createGuestCounterOfferUrl(x_Guest_Token: string): string {
  let url_ = getBaseUrl() + "/v1/guest/counteroffers";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createGuestCounterOfferMutationKey(x_Guest_Token: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'createGuestCounterOffer',
      x_Guest_Token as any,
    ]);
}

/**
 * Create a counter offer as guest
 * @return Counter offer created
 */
export function useCreateGuestCounterOfferMutation<TContext>(x_Guest_Token: string, options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, Types.CounterOfferCreateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CounterOfferDto, unknown, Types.CounterOfferCreateRequest, TContext> {
  const key = createGuestCounterOfferMutationKey(x_Guest_Token);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CounterOfferCreateRequest) => Client().createGuestCounterOffer(x_Guest_Token, body),
    mutationKey: key,
  });
}
  
type CreateGuestCounterOffer__MutationParameters = CreateGuestCounterOfferQueryParameters & {
  body: Types.CounterOfferCreateRequest;
}

/**
 * Create a counter offer as guest
 * @return Counter offer created
 */
export function useCreateGuestCounterOfferMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, CreateGuestCounterOffer__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CreateGuestCounterOfferQueryParameters}): UseMutationResult<Types.CounterOfferDto, unknown, CreateGuestCounterOffer__MutationParameters, TContext> {
  const key = createGuestCounterOfferMutationKey(options?.parameters?.x_Guest_Token!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CreateGuestCounterOffer__MutationParameters) => Client().createGuestCounterOffer(data.x_Guest_Token ?? options?.parameters?.x_Guest_Token!, data.body),
  mutationKey: key,
});
}
  
export function uploadGuestCounterOfferPdfUrl(id: string, x_Guest_Token: string): string {
  let url_ = getBaseUrl() + "/v1/guest/counteroffers/{id}/upload";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadGuestCounterOfferPdfMutationKey(id: string, x_Guest_Token: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'uploadGuestCounterOfferPdf',
      id as any,
      x_Guest_Token as any,
    ]);
}

/**
 * Upload PDF for counter offer as guest
 * @param id Counter offer ID
 * @param body (optional) 
 * @return OK
 */
export function useUploadGuestCounterOfferPdfMutation<TContext>(id: string, x_Guest_Token: string, options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, Types.Body, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CounterOfferDto, unknown, Types.Body, TContext> {
  const key = uploadGuestCounterOfferPdfMutationKey(id, x_Guest_Token);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Body) => Client().uploadGuestCounterOfferPdf(x_Guest_Token, id, body),
    mutationKey: key,
  });
}
  
type UploadGuestCounterOfferPdf__MutationParameters = UploadGuestCounterOfferPdfQueryParameters & {
  body: Types.Body;
}

/**
 * Upload PDF for counter offer as guest
 * @param id Counter offer ID
 * @param body (optional) 
 * @return OK
 */
export function useUploadGuestCounterOfferPdfMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, UploadGuestCounterOfferPdf__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UploadGuestCounterOfferPdfQueryParameters}): UseMutationResult<Types.CounterOfferDto, unknown, UploadGuestCounterOfferPdf__MutationParameters, TContext> {
  const key = uploadGuestCounterOfferPdfMutationKey(options?.parameters?.id!, options?.parameters?.x_Guest_Token!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UploadGuestCounterOfferPdf__MutationParameters) => Client().uploadGuestCounterOfferPdf(data.x_Guest_Token ?? options?.parameters?.x_Guest_Token!, data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function getFieldsUrl(): string {
  let url_ = getBaseUrl() + "/v1/get-fields";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function getFieldsMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'getFields',
    ]);
}

/**
 * Get fields by jurisdiction
 * @return OK
 */
export function useGetFieldsMutation<TContext>(options?: Omit<UseMutationOptions<Types.GetFieldsByJurisdictionResponse, unknown, Types.GetFieldsRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.GetFieldsByJurisdictionResponse, unknown, Types.GetFieldsRequest, TContext> {
  const key = getFieldsMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.GetFieldsRequest) => Client().getFields(body),
    mutationKey: key,
  });
}
  
export function sendForSignatureUrl(documentId: string): string {
  let url_ = getBaseUrl() + "/v1/documents/{documentId}/send-for-signature";
if (documentId === undefined || documentId === null)
  throw new Error("The parameter 'documentId' must be defined.");
url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sendForSignatureMutationKey(documentId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'sendForSignature',
      documentId as any,
    ]);
}

/**
 * Send document for signature
 * @param documentId Document ID
 * @return OK
 */
export function useSendForSignatureMutation<TContext>(documentId: string, options?: Omit<UseMutationOptions<Types.SignatureResponseDTO, unknown, Types.SendForSignatureRequestDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SignatureResponseDTO, unknown, Types.SendForSignatureRequestDTO, TContext> {
  const key = sendForSignatureMutationKey(documentId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SendForSignatureRequestDTO) => Client().sendForSignature(documentId, body),
    mutationKey: key,
  });
}
  
type SendForSignature__MutationParameters = SendForSignatureQueryParameters & {
  body: Types.SendForSignatureRequestDTO;
}

/**
 * Send document for signature
 * @param documentId Document ID
 * @return OK
 */
export function useSendForSignatureMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SignatureResponseDTO, unknown, SendForSignature__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SendForSignatureQueryParameters}): UseMutationResult<Types.SignatureResponseDTO, unknown, SendForSignature__MutationParameters, TContext> {
  const key = sendForSignatureMutationKey(options?.parameters?.documentId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SendForSignature__MutationParameters) => Client().sendForSignature(data.documentId ?? options?.parameters?.documentId!, data.body),
  mutationKey: key,
});
}
  
export function sendEmailUrl(documentId: string): string {
  let url_ = getBaseUrl() + "/v1/documents/{documentId}/send-email";
if (documentId === undefined || documentId === null)
  throw new Error("The parameter 'documentId' must be defined.");
url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sendEmailMutationKey(documentId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'sendEmail',
      documentId as any,
    ]);
}

/**
 * Send document review email
 * @param documentId Document ID
 * @return OK
 */
export function useSendEmailMutation<TContext>(documentId: string, options?: Omit<UseMutationOptions<Types.FileResponse, unknown, Types.SendEmailRequestDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FileResponse, unknown, Types.SendEmailRequestDTO, TContext> {
  const key = sendEmailMutationKey(documentId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SendEmailRequestDTO) => Client().sendEmail(documentId, body),
    mutationKey: key,
  });
}
  
type SendEmail__MutationParameters = SendEmailQueryParameters & {
  body: Types.SendEmailRequestDTO;
}

/**
 * Send document review email
 * @param documentId Document ID
 * @return OK
 */
export function useSendEmailMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.FileResponse, unknown, SendEmail__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SendEmailQueryParameters}): UseMutationResult<Types.FileResponse, unknown, SendEmail__MutationParameters, TContext> {
  const key = sendEmailMutationKey(options?.parameters?.documentId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SendEmail__MutationParameters) => Client().sendEmail(data.documentId ?? options?.parameters?.documentId!, data.body),
  mutationKey: key,
});
}
  
export function listDocumentsUrl(dealId: string): string {
  let url_ = getBaseUrl() + "/v1/documents/deals/{dealId}";
if (dealId === undefined || dealId === null)
  throw new Error("The parameter 'dealId' must be defined.");
url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let listDocumentsDefaultOptions: Omit<UseQueryOptions<Types.DocumentListDto[], unknown, Types.DocumentListDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DocumentListDto[], unknown, Types.DocumentListDto[]>, 'queryFn'>> = {
};
export function getListDocumentsDefaultOptions() {
  return listDocumentsDefaultOptions;
};
export function setListDocumentsDefaultOptions(options: typeof listDocumentsDefaultOptions) {
  listDocumentsDefaultOptions = options;
}

export function listDocumentsQueryKey(dealId: string): QueryKey;
export function listDocumentsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { dealId,  } = params[0] as ListDocumentsQueryParameters;

    return trimArrayEnd([
        'Client',
        'listDocuments',
        dealId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'listDocuments',
        ...params
      ]);
  }
}
export function __listDocuments(context: QueryFunctionContext) {
  return Client().listDocuments(
      context.queryKey[2] as string    );
}

export function useListDocumentsQuery<TSelectData = Types.DocumentListDto[], TError = unknown>(dto: ListDocumentsQueryParameters, options?: Omit<UseQueryOptions<Types.DocumentListDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List documents for a deal
 * @param dealId Deal ID
 * @return OK
 */
export function useListDocumentsQuery<TSelectData = Types.DocumentListDto[], TError = unknown>(dealId: string, options?: Omit<UseQueryOptions<Types.DocumentListDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useListDocumentsQuery<TSelectData = Types.DocumentListDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DocumentListDto[], TError, TSelectData> | undefined = undefined;
  let dealId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ dealId,  } = params[0] as ListDocumentsQueryParameters);
      options = params[1];
    } else {
      [dealId, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DocumentListDto[], TError, TSelectData>({
    queryFn: __listDocuments,
    queryKey: listDocumentsQueryKey(dealId),
    ...listDocumentsDefaultOptions as unknown as Omit<UseQueryOptions<Types.DocumentListDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List documents for a deal
 * @param dealId Deal ID
 * @return OK
 */
export function setListDocumentsData(queryClient: QueryClient, updater: (data: Types.DocumentListDto[] | undefined) => Types.DocumentListDto[], dealId: string) {
  queryClient.setQueryData(listDocumentsQueryKey(dealId),
    updater
  );
}

/**
 * List documents for a deal
 * @param dealId Deal ID
 * @return OK
 */
export function setListDocumentsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DocumentListDto[] | undefined) => Types.DocumentListDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createDocumentUrl(dealId: string): string {
  let url_ = getBaseUrl() + "/v1/documents/deals/{dealId}";
if (dealId === undefined || dealId === null)
  throw new Error("The parameter 'dealId' must be defined.");
url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createDocumentMutationKey(dealId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'createDocument',
      dealId as any,
    ]);
}

/**
 * Create a new document
 * @param dealId Deal ID
 * @return OK
 */
export function useCreateDocumentMutation<TContext>(dealId: string, options?: Omit<UseMutationOptions<Types.DocumentDetailDto, unknown, Types.DocumentCreateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DocumentDetailDto, unknown, Types.DocumentCreateRequest, TContext> {
  const key = createDocumentMutationKey(dealId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DocumentCreateRequest) => Client().createDocument(dealId, body),
    mutationKey: key,
  });
}
  
type CreateDocument__MutationParameters = CreateDocumentQueryParameters & {
  body: Types.DocumentCreateRequest;
}

/**
 * Create a new document
 * @param dealId Deal ID
 * @return OK
 */
export function useCreateDocumentMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DocumentDetailDto, unknown, CreateDocument__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CreateDocumentQueryParameters}): UseMutationResult<Types.DocumentDetailDto, unknown, CreateDocument__MutationParameters, TContext> {
  const key = createDocumentMutationKey(options?.parameters?.dealId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CreateDocument__MutationParameters) => Client().createDocument(data.dealId ?? options?.parameters?.dealId!, data.body),
  mutationKey: key,
});
}
  
export function listDealsUrl(status: string | undefined, search: string | undefined, limit: number | undefined, offset: number | undefined, docType: string | undefined): string {
  let url_ = getBaseUrl() + "/v1/deals?";
if (status === null)
    throw new Error("The parameter 'status' cannot be null.");
else if (status !== undefined)
    url_ += "status=" + encodeURIComponent("" + status) + "&";
if (search === null)
    throw new Error("The parameter 'search' cannot be null.");
else if (search !== undefined)
    url_ += "search=" + encodeURIComponent("" + search) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
if (docType === null)
    throw new Error("The parameter 'docType' cannot be null.");
else if (docType !== undefined)
    url_ += "docType=" + encodeURIComponent("" + docType) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let listDealsDefaultOptions: Omit<UseQueryOptions<Types.DealListResponseDto, unknown, Types.DealListResponseDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DealListResponseDto, unknown, Types.DealListResponseDto>, 'queryFn'>> = {
};
export function getListDealsDefaultOptions() {
  return listDealsDefaultOptions;
};
export function setListDealsDefaultOptions(options: typeof listDealsDefaultOptions) {
  listDealsDefaultOptions = options;
}

export function listDealsQueryKey(dto: ListDealsQueryParameters): QueryKey;
export function listDealsQueryKey(status: string | undefined, search: string | undefined, limit: number | undefined, offset: number | undefined, docType: string | undefined): QueryKey;
export function listDealsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { status, search, limit, offset, docType,  } = params[0] as ListDealsQueryParameters;

    return trimArrayEnd([
        'Client',
        'listDeals',
        status as any,
        search as any,
        limit as any,
        offset as any,
        docType as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'listDeals',
        ...params
      ]);
  }
}
export function __listDeals(context: QueryFunctionContext) {
  return Client().listDeals(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as string | undefined    );
}

export function useListDealsQuery<TSelectData = Types.DealListResponseDto, TError = unknown>(dto: ListDealsQueryParameters, options?: Omit<UseQueryOptions<Types.DealListResponseDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List deals with pagination and filtering
 * @param status (optional) Filter by status: DRAFT, WAITING_SIGNATURE, COMPLETED, BLOCKED
 * @param search (optional) Search by address, buyer name, seller name, or MLS ID
 * @param limit (optional) Number of results per page (default: 50)
 * @param offset (optional) Pagination offset (default: 0)
 * @param docType (optional) Filter by document type: CONTRACT, BBA, ADDENDUM, etc. Only deals with at least one document of this type are returned.
 * @return OK
 */
export function useListDealsQuery<TSelectData = Types.DealListResponseDto, TError = unknown>(status: string | undefined, search: string | undefined, limit: number | undefined, offset: number | undefined, docType: string | undefined, options?: Omit<UseQueryOptions<Types.DealListResponseDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useListDealsQuery<TSelectData = Types.DealListResponseDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DealListResponseDto, TError, TSelectData> | undefined = undefined;
  let status: any = undefined;
  let search: any = undefined;
  let limit: any = undefined;
  let offset: any = undefined;
  let docType: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ status, search, limit, offset, docType,  } = params[0] as ListDealsQueryParameters);
      options = params[1];
    } else {
      [status, search, limit, offset, docType, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DealListResponseDto, TError, TSelectData>({
    queryFn: __listDeals,
    queryKey: listDealsQueryKey(status, search, limit, offset, docType),
    ...listDealsDefaultOptions as unknown as Omit<UseQueryOptions<Types.DealListResponseDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List deals with pagination and filtering
 * @param status (optional) Filter by status: DRAFT, WAITING_SIGNATURE, COMPLETED, BLOCKED
 * @param search (optional) Search by address, buyer name, seller name, or MLS ID
 * @param limit (optional) Number of results per page (default: 50)
 * @param offset (optional) Pagination offset (default: 0)
 * @param docType (optional) Filter by document type: CONTRACT, BBA, ADDENDUM, etc. Only deals with at least one document of this type are returned.
 * @return OK
 */
export function setListDealsData(queryClient: QueryClient, updater: (data: Types.DealListResponseDto | undefined) => Types.DealListResponseDto, status: string | undefined, search: string | undefined, limit: number | undefined, offset: number | undefined, docType: string | undefined) {
  queryClient.setQueryData(listDealsQueryKey(status, search, limit, offset, docType),
    updater
  );
}

/**
 * List deals with pagination and filtering
 * @param status (optional) Filter by status: DRAFT, WAITING_SIGNATURE, COMPLETED, BLOCKED
 * @param search (optional) Search by address, buyer name, seller name, or MLS ID
 * @param limit (optional) Number of results per page (default: 50)
 * @param offset (optional) Pagination offset (default: 0)
 * @param docType (optional) Filter by document type: CONTRACT, BBA, ADDENDUM, etc. Only deals with at least one document of this type are returned.
 * @return OK
 */
export function setListDealsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DealListResponseDto | undefined) => Types.DealListResponseDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createDealUrl(): string {
  let url_ = getBaseUrl() + "/v1/deals";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createDealMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createDeal',
    ]);
}

/**
 * Create a new deal
 * @return OK
 */
export function useCreateDealMutation<TContext>(options?: Omit<UseMutationOptions<Types.DealDetailDto, unknown, Types.DealCreateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DealDetailDto, unknown, Types.DealCreateRequest, TContext> {
  const key = createDealMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DealCreateRequest) => Client().createDeal(body),
    mutationKey: key,
  });
}
  
export function listGuestLinksUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/guest-links";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let listGuestLinksDefaultOptions: Omit<UseQueryOptions<Types.GuestLinkDto[], unknown, Types.GuestLinkDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.GuestLinkDto[], unknown, Types.GuestLinkDto[]>, 'queryFn'>> = {
};
export function getListGuestLinksDefaultOptions() {
  return listGuestLinksDefaultOptions;
};
export function setListGuestLinksDefaultOptions(options: typeof listGuestLinksDefaultOptions) {
  listGuestLinksDefaultOptions = options;
}

export function listGuestLinksQueryKey(id: string): QueryKey;
export function listGuestLinksQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ListGuestLinksQueryParameters;

    return trimArrayEnd([
        'Client',
        'listGuestLinks',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'listGuestLinks',
        ...params
      ]);
  }
}
export function __listGuestLinks(context: QueryFunctionContext) {
  return Client().listGuestLinks(
      context.queryKey[2] as string    );
}

export function useListGuestLinksQuery<TSelectData = Types.GuestLinkDto[], TError = unknown>(dto: ListGuestLinksQueryParameters, options?: Omit<UseQueryOptions<Types.GuestLinkDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List guest links
 * @return OK
 */
export function useListGuestLinksQuery<TSelectData = Types.GuestLinkDto[], TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.GuestLinkDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useListGuestLinksQuery<TSelectData = Types.GuestLinkDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GuestLinkDto[], TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ListGuestLinksQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.GuestLinkDto[], TError, TSelectData>({
    queryFn: __listGuestLinks,
    queryKey: listGuestLinksQueryKey(id),
    ...listGuestLinksDefaultOptions as unknown as Omit<UseQueryOptions<Types.GuestLinkDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List guest links
 * @return OK
 */
export function setListGuestLinksData(queryClient: QueryClient, updater: (data: Types.GuestLinkDto[] | undefined) => Types.GuestLinkDto[], id: string) {
  queryClient.setQueryData(listGuestLinksQueryKey(id),
    updater
  );
}

/**
 * List guest links
 * @return OK
 */
export function setListGuestLinksDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GuestLinkDto[] | undefined) => Types.GuestLinkDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createGuestLinkUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/guest-links";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createGuestLinkMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'createGuestLink',
      id as any,
    ]);
}

/**
 * Create a guest link
 * @return OK
 */
export function useCreateGuestLinkMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.GuestLinkDto, unknown, Types.GuestLinkCreateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.GuestLinkDto, unknown, Types.GuestLinkCreateRequest, TContext> {
  const key = createGuestLinkMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.GuestLinkCreateRequest) => Client().createGuestLink(id, body),
    mutationKey: key,
  });
}
  
type CreateGuestLink__MutationParameters = CreateGuestLinkQueryParameters & {
  body: Types.GuestLinkCreateRequest;
}

/**
 * Create a guest link
 * @return OK
 */
export function useCreateGuestLinkMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.GuestLinkDto, unknown, CreateGuestLink__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CreateGuestLinkQueryParameters}): UseMutationResult<Types.GuestLinkDto, unknown, CreateGuestLink__MutationParameters, TContext> {
  const key = createGuestLinkMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CreateGuestLink__MutationParameters) => Client().createGuestLink(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function listCounterOffersUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/counteroffers";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let listCounterOffersDefaultOptions: Omit<UseQueryOptions<Types.CounterOfferDto[], unknown, Types.CounterOfferDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CounterOfferDto[], unknown, Types.CounterOfferDto[]>, 'queryFn'>> = {
};
export function getListCounterOffersDefaultOptions() {
  return listCounterOffersDefaultOptions;
};
export function setListCounterOffersDefaultOptions(options: typeof listCounterOffersDefaultOptions) {
  listCounterOffersDefaultOptions = options;
}

export function listCounterOffersQueryKey(id: string): QueryKey;
export function listCounterOffersQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ListCounterOffersQueryParameters;

    return trimArrayEnd([
        'Client',
        'listCounterOffers',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'listCounterOffers',
        ...params
      ]);
  }
}
export function __listCounterOffers(context: QueryFunctionContext) {
  return Client().listCounterOffers(
      context.queryKey[2] as string    );
}

export function useListCounterOffersQuery<TSelectData = Types.CounterOfferDto[], TError = unknown>(dto: ListCounterOffersQueryParameters, options?: Omit<UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List counter offers for a deal
 * @param id Deal ID
 * @return OK
 */
export function useListCounterOffersQuery<TSelectData = Types.CounterOfferDto[], TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useListCounterOffersQuery<TSelectData = Types.CounterOfferDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ListCounterOffersQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CounterOfferDto[], TError, TSelectData>({
    queryFn: __listCounterOffers,
    queryKey: listCounterOffersQueryKey(id),
    ...listCounterOffersDefaultOptions as unknown as Omit<UseQueryOptions<Types.CounterOfferDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List counter offers for a deal
 * @param id Deal ID
 * @return OK
 */
export function setListCounterOffersData(queryClient: QueryClient, updater: (data: Types.CounterOfferDto[] | undefined) => Types.CounterOfferDto[], id: string) {
  queryClient.setQueryData(listCounterOffersQueryKey(id),
    updater
  );
}

/**
 * List counter offers for a deal
 * @param id Deal ID
 * @return OK
 */
export function setListCounterOffersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CounterOfferDto[] | undefined) => Types.CounterOfferDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createCounterOfferUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/counteroffers";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createCounterOfferMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'createCounterOffer',
      id as any,
    ]);
}

/**
 * Create a counter offer
 * @param id Deal ID
 * @return Counter offer created
 */
export function useCreateCounterOfferMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, Types.CounterOfferCreateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CounterOfferDto, unknown, Types.CounterOfferCreateRequest, TContext> {
  const key = createCounterOfferMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CounterOfferCreateRequest) => Client().createCounterOffer(id, body),
    mutationKey: key,
  });
}
  
type CreateCounterOffer__MutationParameters = CreateCounterOfferQueryParameters & {
  body: Types.CounterOfferCreateRequest;
}

/**
 * Create a counter offer
 * @param id Deal ID
 * @return Counter offer created
 */
export function useCreateCounterOfferMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, CreateCounterOffer__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CreateCounterOfferQueryParameters}): UseMutationResult<Types.CounterOfferDto, unknown, CreateCounterOffer__MutationParameters, TContext> {
  const key = createCounterOfferMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CreateCounterOffer__MutationParameters) => Client().createCounterOffer(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function uploadCounterOfferPdfUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/counteroffers/{id}/upload";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadCounterOfferPdfMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'uploadCounterOfferPdf',
      id as any,
    ]);
}

/**
 * Upload signed PDF for counter offer
 * @param id Counter offer ID
 * @param body (optional) 
 * @return OK
 */
export function useUploadCounterOfferPdfMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, Types.Body2, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CounterOfferDto, unknown, Types.Body2, TContext> {
  const key = uploadCounterOfferPdfMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Body2) => Client().uploadCounterOfferPdf(id, body),
    mutationKey: key,
  });
}
  
type UploadCounterOfferPdf__MutationParameters = UploadCounterOfferPdfQueryParameters & {
  body: Types.Body2;
}

/**
 * Upload signed PDF for counter offer
 * @param id Counter offer ID
 * @param body (optional) 
 * @return OK
 */
export function useUploadCounterOfferPdfMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, UploadCounterOfferPdf__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UploadCounterOfferPdfQueryParameters}): UseMutationResult<Types.CounterOfferDto, unknown, UploadCounterOfferPdf__MutationParameters, TContext> {
  const key = uploadCounterOfferPdfMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UploadCounterOfferPdf__MutationParameters) => Client().uploadCounterOfferPdf(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function searchBbaByBuyerNameUrl(): string {
  let url_ = getBaseUrl() + "/v1/bba/search";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function searchBbaByBuyerNameMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'searchBbaByBuyerName',
    ]);
}

/**
 * Search BBA by buyer name
 * @return OK
 */
export function useSearchBbaByBuyerNameMutation<TContext>(options?: Omit<UseMutationOptions<Types.BbaSearchResponse, unknown, Types.BbaSearchRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.BbaSearchResponse, unknown, Types.BbaSearchRequest, TContext> {
  const key = searchBbaByBuyerNameMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.BbaSearchRequest) => Client().searchBbaByBuyerName(body),
    mutationKey: key,
  });
}
  
export function getCounterOfferUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/counteroffers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getCounterOfferDefaultOptions: Omit<UseQueryOptions<Types.CounterOfferDto, unknown, Types.CounterOfferDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CounterOfferDto, unknown, Types.CounterOfferDto>, 'queryFn'>> = {
};
export function getGetCounterOfferDefaultOptions() {
  return getCounterOfferDefaultOptions;
};
export function setGetCounterOfferDefaultOptions(options: typeof getCounterOfferDefaultOptions) {
  getCounterOfferDefaultOptions = options;
}

export function getCounterOfferQueryKey(id: string): QueryKey;
export function getCounterOfferQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetCounterOfferQueryParameters;

    return trimArrayEnd([
        'Client',
        'getCounterOffer',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getCounterOffer',
        ...params
      ]);
  }
}
export function __getCounterOffer(context: QueryFunctionContext) {
  return Client().getCounterOffer(
      context.queryKey[2] as string    );
}

export function useGetCounterOfferQuery<TSelectData = Types.CounterOfferDto, TError = unknown>(dto: GetCounterOfferQueryParameters, options?: Omit<UseQueryOptions<Types.CounterOfferDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get counter offer details
 * @param id Counter offer ID
 * @return OK
 */
export function useGetCounterOfferQuery<TSelectData = Types.CounterOfferDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.CounterOfferDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetCounterOfferQuery<TSelectData = Types.CounterOfferDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CounterOfferDto, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetCounterOfferQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CounterOfferDto, TError, TSelectData>({
    queryFn: __getCounterOffer,
    queryKey: getCounterOfferQueryKey(id),
    ...getCounterOfferDefaultOptions as unknown as Omit<UseQueryOptions<Types.CounterOfferDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get counter offer details
 * @param id Counter offer ID
 * @return OK
 */
export function setGetCounterOfferData(queryClient: QueryClient, updater: (data: Types.CounterOfferDto | undefined) => Types.CounterOfferDto, id: string) {
  queryClient.setQueryData(getCounterOfferQueryKey(id),
    updater
  );
}

/**
 * Get counter offer details
 * @param id Counter offer ID
 * @return OK
 */
export function setGetCounterOfferDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CounterOfferDto | undefined) => Types.CounterOfferDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function deleteCounterOfferUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/counteroffers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteCounterOfferMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteCounterOffer',
      id as any,
    ]);
}

/**
 * Delete a counter offer (soft delete)
 * @param id Counter offer ID
 * @return OK
 */
export function useDeleteCounterOfferMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteCounterOfferMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteCounterOffer(id),
    mutationKey: key,
  });
}
  
type DeleteCounterOffer__MutationParameters = DeleteCounterOfferQueryParameters

/**
 * Delete a counter offer (soft delete)
 * @param id Counter offer ID
 * @return OK
 */
export function useDeleteCounterOfferMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteCounterOffer__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteCounterOfferQueryParameters}): UseMutationResult<void, unknown, DeleteCounterOffer__MutationParameters, TContext> {
  const key = deleteCounterOfferMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteCounterOffer__MutationParameters) => Client().deleteCounterOffer(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function updateCounterOfferUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/counteroffers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateCounterOfferMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateCounterOffer',
      id as any,
    ]);
}

/**
 * Update a counter offer
 * @param id Counter offer ID
 * @return OK
 */
export function useUpdateCounterOfferMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, Types.CounterOfferUpdateRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CounterOfferDto, unknown, Types.CounterOfferUpdateRequest, TContext> {
  const key = updateCounterOfferMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CounterOfferUpdateRequest) => Client().updateCounterOffer(id, body),
    mutationKey: key,
  });
}
  
type UpdateCounterOffer__MutationParameters = UpdateCounterOfferQueryParameters & {
  body: Types.CounterOfferUpdateRequest;
}

/**
 * Update a counter offer
 * @param id Counter offer ID
 * @return OK
 */
export function useUpdateCounterOfferMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CounterOfferDto, unknown, UpdateCounterOffer__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateCounterOfferQueryParameters}): UseMutationResult<Types.CounterOfferDto, unknown, UpdateCounterOffer__MutationParameters, TContext> {
  const key = updateCounterOfferMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateCounterOffer__MutationParameters) => Client().updateCounterOffer(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function getTemplateVersionByIdUrl(id: string, status: Types.Status): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}/prompts/{status}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (status === undefined || status === null)
  throw new Error("The parameter 'status' must be defined.");
url_ = url_.replace("{status}", encodeURIComponent("" + status));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getTemplateVersionByIdDefaultOptions: Omit<UseQueryOptions<Types.ContractTemplateVersionDto, unknown, Types.ContractTemplateVersionDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ContractTemplateVersionDto, unknown, Types.ContractTemplateVersionDto>, 'queryFn'>> = {
};
export function getGetTemplateVersionByIdDefaultOptions() {
  return getTemplateVersionByIdDefaultOptions;
};
export function setGetTemplateVersionByIdDefaultOptions(options: typeof getTemplateVersionByIdDefaultOptions) {
  getTemplateVersionByIdDefaultOptions = options;
}

export function getTemplateVersionByIdQueryKey(dto: GetTemplateVersionByIdQueryParameters): QueryKey;
export function getTemplateVersionByIdQueryKey(id: string, status: Types.Status): QueryKey;
export function getTemplateVersionByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, status,  } = params[0] as GetTemplateVersionByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getTemplateVersionById',
        id as any,
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getTemplateVersionById',
        ...params
      ]);
  }
}
export function __getTemplateVersionById(context: QueryFunctionContext) {
  return Client().getTemplateVersionById(
      context.queryKey[2] as string,       context.queryKey[3] as Types.Status    );
}

export function useGetTemplateVersionByIdQuery<TSelectData = Types.ContractTemplateVersionDto, TError = unknown>(dto: GetTemplateVersionByIdQueryParameters, options?: Omit<UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get template version by status
 * @param id Template ID
 * @param status Version status
 * @return OK
 */
export function useGetTemplateVersionByIdQuery<TSelectData = Types.ContractTemplateVersionDto, TError = unknown>(id: string, status: Types.Status, options?: Omit<UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetTemplateVersionByIdQuery<TSelectData = Types.ContractTemplateVersionDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, status,  } = params[0] as GetTemplateVersionByIdQueryParameters);
      options = params[1];
    } else {
      [id, status, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ContractTemplateVersionDto, TError, TSelectData>({
    queryFn: __getTemplateVersionById,
    queryKey: getTemplateVersionByIdQueryKey(id, status),
    ...getTemplateVersionByIdDefaultOptions as unknown as Omit<UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get template version by status
 * @param id Template ID
 * @param status Version status
 * @return OK
 */
export function setGetTemplateVersionByIdData(queryClient: QueryClient, updater: (data: Types.ContractTemplateVersionDto | undefined) => Types.ContractTemplateVersionDto, id: string, status: Types.Status) {
  queryClient.setQueryData(getTemplateVersionByIdQueryKey(id, status),
    updater
  );
}

/**
 * Get template version by status
 * @param id Template ID
 * @param status Version status
 * @return OK
 */
export function setGetTemplateVersionByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ContractTemplateVersionDto | undefined) => Types.ContractTemplateVersionDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getTemplatePdfmeLayoutUrl(id: string, status: Types.Status2): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}/pdfme-layout/{status}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (status === undefined || status === null)
  throw new Error("The parameter 'status' must be defined.");
url_ = url_.replace("{status}", encodeURIComponent("" + status));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getTemplatePdfmeLayoutDefaultOptions: Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, unknown, Types.PdfmeLayoutUpdateRequest>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, unknown, Types.PdfmeLayoutUpdateRequest>, 'queryFn'>> = {
};
export function getGetTemplatePdfmeLayoutDefaultOptions() {
  return getTemplatePdfmeLayoutDefaultOptions;
};
export function setGetTemplatePdfmeLayoutDefaultOptions(options: typeof getTemplatePdfmeLayoutDefaultOptions) {
  getTemplatePdfmeLayoutDefaultOptions = options;
}

export function getTemplatePdfmeLayoutQueryKey(dto: GetTemplatePdfmeLayoutQueryParameters): QueryKey;
export function getTemplatePdfmeLayoutQueryKey(id: string, status: Types.Status2): QueryKey;
export function getTemplatePdfmeLayoutQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, status,  } = params[0] as GetTemplatePdfmeLayoutQueryParameters;

    return trimArrayEnd([
        'Client',
        'getTemplatePdfmeLayout',
        id as any,
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getTemplatePdfmeLayout',
        ...params
      ]);
  }
}
export function __getTemplatePdfmeLayout(context: QueryFunctionContext) {
  return Client().getTemplatePdfmeLayout(
      context.queryKey[2] as string,       context.queryKey[3] as Types.Status2    );
}

export function useGetTemplatePdfmeLayoutQuery<TSelectData = Types.PdfmeLayoutUpdateRequest, TError = unknown>(dto: GetTemplatePdfmeLayoutQueryParameters, options?: Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get PDFME layout
 * @param id Template ID
 * @param status Version status
 * @return OK
 */
export function useGetTemplatePdfmeLayoutQuery<TSelectData = Types.PdfmeLayoutUpdateRequest, TError = unknown>(id: string, status: Types.Status2, options?: Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetTemplatePdfmeLayoutQuery<TSelectData = Types.PdfmeLayoutUpdateRequest, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, status,  } = params[0] as GetTemplatePdfmeLayoutQueryParameters);
      options = params[1];
    } else {
      [id, status, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>({
    queryFn: __getTemplatePdfmeLayout,
    queryKey: getTemplatePdfmeLayoutQueryKey(id, status),
    ...getTemplatePdfmeLayoutDefaultOptions as unknown as Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get PDFME layout
 * @param id Template ID
 * @param status Version status
 * @return OK
 */
export function setGetTemplatePdfmeLayoutData(queryClient: QueryClient, updater: (data: Types.PdfmeLayoutUpdateRequest | undefined) => Types.PdfmeLayoutUpdateRequest, id: string, status: Types.Status2) {
  queryClient.setQueryData(getTemplatePdfmeLayoutQueryKey(id, status),
    updater
  );
}

/**
 * Get PDFME layout
 * @param id Template ID
 * @param status Version status
 * @return OK
 */
export function setGetTemplatePdfmeLayoutDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PdfmeLayoutUpdateRequest | undefined) => Types.PdfmeLayoutUpdateRequest) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getAllTemplateVersionsUrl(status: Types.Status3): string {
  let url_ = getBaseUrl() + "/v1/templates/list/{status}";
if (status === undefined || status === null)
  throw new Error("The parameter 'status' must be defined.");
url_ = url_.replace("{status}", encodeURIComponent("" + status));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAllTemplateVersionsDefaultOptions: Omit<UseQueryOptions<Types.ContractTemplateVersionDto[], unknown, Types.ContractTemplateVersionDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ContractTemplateVersionDto[], unknown, Types.ContractTemplateVersionDto[]>, 'queryFn'>> = {
};
export function getGetAllTemplateVersionsDefaultOptions() {
  return getAllTemplateVersionsDefaultOptions;
};
export function setGetAllTemplateVersionsDefaultOptions(options: typeof getAllTemplateVersionsDefaultOptions) {
  getAllTemplateVersionsDefaultOptions = options;
}

export function getAllTemplateVersionsQueryKey(status: Types.Status3): QueryKey;
export function getAllTemplateVersionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { status,  } = params[0] as GetAllTemplateVersionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'getAllTemplateVersions',
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getAllTemplateVersions',
        ...params
      ]);
  }
}
export function __getAllTemplateVersions(context: QueryFunctionContext) {
  return Client().getAllTemplateVersions(
      context.queryKey[2] as Types.Status3    );
}

export function useGetAllTemplateVersionsQuery<TSelectData = Types.ContractTemplateVersionDto[], TError = unknown>(dto: GetAllTemplateVersionsQueryParameters, options?: Omit<UseQueryOptions<Types.ContractTemplateVersionDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get All template versions by status
 * @param status Version status
 * @return OK
 */
export function useGetAllTemplateVersionsQuery<TSelectData = Types.ContractTemplateVersionDto[], TError = unknown>(status: Types.Status3, options?: Omit<UseQueryOptions<Types.ContractTemplateVersionDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetAllTemplateVersionsQuery<TSelectData = Types.ContractTemplateVersionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ContractTemplateVersionDto[], TError, TSelectData> | undefined = undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ status,  } = params[0] as GetAllTemplateVersionsQueryParameters);
      options = params[1];
    } else {
      [status, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ContractTemplateVersionDto[], TError, TSelectData>({
    queryFn: __getAllTemplateVersions,
    queryKey: getAllTemplateVersionsQueryKey(status),
    ...getAllTemplateVersionsDefaultOptions as unknown as Omit<UseQueryOptions<Types.ContractTemplateVersionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get All template versions by status
 * @param status Version status
 * @return OK
 */
export function setGetAllTemplateVersionsData(queryClient: QueryClient, updater: (data: Types.ContractTemplateVersionDto[] | undefined) => Types.ContractTemplateVersionDto[], status: Types.Status3) {
  queryClient.setQueryData(getAllTemplateVersionsQueryKey(status),
    updater
  );
}

/**
 * Get All template versions by status
 * @param status Version status
 * @return OK
 */
export function setGetAllTemplateVersionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ContractTemplateVersionDto[] | undefined) => Types.ContractTemplateVersionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function findOrCreateTemplateUrl(jurisdictionCode: string, templateType: Types.TemplateType, slug: string | undefined): string {
  let url_ = getBaseUrl() + "/v1/templates/find?";
  if (jurisdictionCode === undefined || jurisdictionCode === null)
    throw new Error("The parameter 'jurisdictionCode' must be defined and cannot be null.");
  else
    url_ += "jurisdictionCode=" + encodeURIComponent("" + jurisdictionCode) + "&";
  if (templateType === undefined || templateType === null)
    throw new Error("The parameter 'templateType' must be defined and cannot be null.");
  else
    url_ += "templateType=" + encodeURIComponent("" + templateType) + "&";
if (slug === null)
    throw new Error("The parameter 'slug' cannot be null.");
else if (slug !== undefined)
    url_ += "slug=" + encodeURIComponent("" + slug) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findOrCreateTemplateDefaultOptions: Omit<UseQueryOptions<Types.ContractTemplateVersionDto, unknown, Types.ContractTemplateVersionDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ContractTemplateVersionDto, unknown, Types.ContractTemplateVersionDto>, 'queryFn'>> = {
};
export function getFindOrCreateTemplateDefaultOptions() {
  return findOrCreateTemplateDefaultOptions;
};
export function setFindOrCreateTemplateDefaultOptions(options: typeof findOrCreateTemplateDefaultOptions) {
  findOrCreateTemplateDefaultOptions = options;
}

export function findOrCreateTemplateQueryKey(dto: FindOrCreateTemplateQueryParameters): QueryKey;
export function findOrCreateTemplateQueryKey(jurisdictionCode: string, templateType: Types.TemplateType, slug: string | undefined): QueryKey;
export function findOrCreateTemplateQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { jurisdictionCode, templateType, slug,  } = params[0] as FindOrCreateTemplateQueryParameters;

    return trimArrayEnd([
        'Client',
        'findOrCreateTemplate',
        jurisdictionCode as any,
        templateType as any,
        slug as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'findOrCreateTemplate',
        ...params
      ]);
  }
}
export function __findOrCreateTemplate(context: QueryFunctionContext) {
  return Client().findOrCreateTemplate(
      context.queryKey[2] as string,       context.queryKey[3] as Types.TemplateType,       context.queryKey[4] as string | undefined    );
}

export function useFindOrCreateTemplateQuery<TSelectData = Types.ContractTemplateVersionDto, TError = unknown>(dto: FindOrCreateTemplateQueryParameters, options?: Omit<UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Find or auto-create template
 * @param jurisdictionCode Jurisdiction code (e.g., CA, TX)
 * @param templateType Template type
 * @param slug (optional) Slug for ADDENDA templates (required for ADDENDA)
 * @return OK
 */
export function useFindOrCreateTemplateQuery<TSelectData = Types.ContractTemplateVersionDto, TError = unknown>(jurisdictionCode: string, templateType: Types.TemplateType, slug: string | undefined, options?: Omit<UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useFindOrCreateTemplateQuery<TSelectData = Types.ContractTemplateVersionDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData> | undefined = undefined;
  let jurisdictionCode: any = undefined;
  let templateType: any = undefined;
  let slug: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ jurisdictionCode, templateType, slug,  } = params[0] as FindOrCreateTemplateQueryParameters);
      options = params[1];
    } else {
      [jurisdictionCode, templateType, slug, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ContractTemplateVersionDto, TError, TSelectData>({
    queryFn: __findOrCreateTemplate,
    queryKey: findOrCreateTemplateQueryKey(jurisdictionCode, templateType, slug),
    ...findOrCreateTemplateDefaultOptions as unknown as Omit<UseQueryOptions<Types.ContractTemplateVersionDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Find or auto-create template
 * @param jurisdictionCode Jurisdiction code (e.g., CA, TX)
 * @param templateType Template type
 * @param slug (optional) Slug for ADDENDA templates (required for ADDENDA)
 * @return OK
 */
export function setFindOrCreateTemplateData(queryClient: QueryClient, updater: (data: Types.ContractTemplateVersionDto | undefined) => Types.ContractTemplateVersionDto, jurisdictionCode: string, templateType: Types.TemplateType, slug: string | undefined) {
  queryClient.setQueryData(findOrCreateTemplateQueryKey(jurisdictionCode, templateType, slug),
    updater
  );
}

/**
 * Find or auto-create template
 * @param jurisdictionCode Jurisdiction code (e.g., CA, TX)
 * @param templateType Template type
 * @param slug (optional) Slug for ADDENDA templates (required for ADDENDA)
 * @return OK
 */
export function setFindOrCreateTemplateDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ContractTemplateVersionDto | undefined) => Types.ContractTemplateVersionDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getAddendumPdfmeLayoutUrl(addendumSlug: string, userId: string | undefined, status: Types.Status4 | undefined): string {
  let url_ = getBaseUrl() + "/v1/templates/addendum/{addendumSlug}/pdfme-layout?";
if (addendumSlug === undefined || addendumSlug === null)
  throw new Error("The parameter 'addendumSlug' must be defined.");
url_ = url_.replace("{addendumSlug}", encodeURIComponent("" + addendumSlug));
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
if (status === null)
    throw new Error("The parameter 'status' cannot be null.");
else if (status !== undefined)
    url_ += "status=" + encodeURIComponent("" + status) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAddendumPdfmeLayoutDefaultOptions: Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, unknown, Types.PdfmeLayoutUpdateRequest>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, unknown, Types.PdfmeLayoutUpdateRequest>, 'queryFn'>> = {
};
export function getGetAddendumPdfmeLayoutDefaultOptions() {
  return getAddendumPdfmeLayoutDefaultOptions;
};
export function setGetAddendumPdfmeLayoutDefaultOptions(options: typeof getAddendumPdfmeLayoutDefaultOptions) {
  getAddendumPdfmeLayoutDefaultOptions = options;
}

export function getAddendumPdfmeLayoutQueryKey(dto: GetAddendumPdfmeLayoutQueryParameters): QueryKey;
export function getAddendumPdfmeLayoutQueryKey(addendumSlug: string, userId: string | undefined, status: Types.Status4 | undefined): QueryKey;
export function getAddendumPdfmeLayoutQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { addendumSlug, userId, status,  } = params[0] as GetAddendumPdfmeLayoutQueryParameters;

    return trimArrayEnd([
        'Client',
        'getAddendumPdfmeLayout',
        addendumSlug as any,
        userId as any,
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getAddendumPdfmeLayout',
        ...params
      ]);
  }
}
export function __getAddendumPdfmeLayout(context: QueryFunctionContext) {
  return Client().getAddendumPdfmeLayout(
      context.queryKey[2] as string,       context.queryKey[3] as string | undefined,       context.queryKey[4] as Types.Status4 | undefined    );
}

export function useGetAddendumPdfmeLayoutQuery<TSelectData = Types.PdfmeLayoutUpdateRequest, TError = unknown>(dto: GetAddendumPdfmeLayoutQueryParameters, options?: Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get addendum PDFME layout by slug and userId
 * @param addendumSlug Addendum slug (e.g. hoa, solar-addendum)
 * @param userId (optional) User ID (clerkId) - used to determine jurisdiction. Falls back to auth principal if not provided.
 * @param status (optional) Version status
 * @return OK
 */
export function useGetAddendumPdfmeLayoutQuery<TSelectData = Types.PdfmeLayoutUpdateRequest, TError = unknown>(addendumSlug: string, userId: string | undefined, status: Types.Status4 | undefined, options?: Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetAddendumPdfmeLayoutQuery<TSelectData = Types.PdfmeLayoutUpdateRequest, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData> | undefined = undefined;
  let addendumSlug: any = undefined;
  let userId: any = undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ addendumSlug, userId, status,  } = params[0] as GetAddendumPdfmeLayoutQueryParameters);
      options = params[1];
    } else {
      [addendumSlug, userId, status, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>({
    queryFn: __getAddendumPdfmeLayout,
    queryKey: getAddendumPdfmeLayoutQueryKey(addendumSlug, userId, status),
    ...getAddendumPdfmeLayoutDefaultOptions as unknown as Omit<UseQueryOptions<Types.PdfmeLayoutUpdateRequest, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get addendum PDFME layout by slug and userId
 * @param addendumSlug Addendum slug (e.g. hoa, solar-addendum)
 * @param userId (optional) User ID (clerkId) - used to determine jurisdiction. Falls back to auth principal if not provided.
 * @param status (optional) Version status
 * @return OK
 */
export function setGetAddendumPdfmeLayoutData(queryClient: QueryClient, updater: (data: Types.PdfmeLayoutUpdateRequest | undefined) => Types.PdfmeLayoutUpdateRequest, addendumSlug: string, userId: string | undefined, status: Types.Status4 | undefined) {
  queryClient.setQueryData(getAddendumPdfmeLayoutQueryKey(addendumSlug, userId, status),
    updater
  );
}

/**
 * Get addendum PDFME layout by slug and userId
 * @param addendumSlug Addendum slug (e.g. hoa, solar-addendum)
 * @param userId (optional) User ID (clerkId) - used to determine jurisdiction. Falls back to auth principal if not provided.
 * @param status (optional) Version status
 * @return OK
 */
export function setGetAddendumPdfmeLayoutDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PdfmeLayoutUpdateRequest | undefined) => Types.PdfmeLayoutUpdateRequest) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function matchAddressUrl(postalCode: string, streetNumber: string, premisesAddress: string): string {
  let url_ = getBaseUrl() + "/v1/mls/match?";
  if (postalCode === undefined || postalCode === null)
    throw new Error("The parameter 'postalCode' must be defined and cannot be null.");
  else
    url_ += "postalCode=" + encodeURIComponent("" + postalCode) + "&";
  if (streetNumber === undefined || streetNumber === null)
    throw new Error("The parameter 'streetNumber' must be defined and cannot be null.");
  else
    url_ += "streetNumber=" + encodeURIComponent("" + streetNumber) + "&";
  if (premisesAddress === undefined || premisesAddress === null)
    throw new Error("The parameter 'premisesAddress' must be defined and cannot be null.");
  else
    url_ += "premisesAddress=" + encodeURIComponent("" + premisesAddress) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let matchAddressDefaultOptions: Omit<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryFn'>> = {
};
export function getMatchAddressDefaultOptions() {
  return matchAddressDefaultOptions;
};
export function setMatchAddressDefaultOptions(options: typeof matchAddressDefaultOptions) {
  matchAddressDefaultOptions = options;
}

export function matchAddressQueryKey(dto: MatchAddressQueryParameters): QueryKey;
export function matchAddressQueryKey(postalCode: string, streetNumber: string, premisesAddress: string): QueryKey;
export function matchAddressQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { postalCode, streetNumber, premisesAddress,  } = params[0] as MatchAddressQueryParameters;

    return trimArrayEnd([
        'Client',
        'matchAddress',
        postalCode as any,
        streetNumber as any,
        premisesAddress as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'matchAddress',
        ...params
      ]);
  }
}
export function __matchAddress(context: QueryFunctionContext) {
  return Client().matchAddress(
      context.queryKey[2] as string,       context.queryKey[3] as string,       context.queryKey[4] as string    );
}

export function useMatchAddressQuery<TSelectData = Types.FileResponse, TError = unknown>(dto: MatchAddressQueryParameters, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Find the best matching listing for an address
 * @param postalCode Postal code of the property, e.g., '85251'
 * @param streetNumber Street number of the property, e.g., '8507'
 * @param premisesAddress Full premises address, e.g., '8507 EMONTECyTO Avenue Scottsdale, Arizona 85251'
 * @return OK
 */
export function useMatchAddressQuery<TSelectData = Types.FileResponse, TError = unknown>(postalCode: string, streetNumber: string, premisesAddress: string, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useMatchAddressQuery<TSelectData = Types.FileResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileResponse, TError, TSelectData> | undefined = undefined;
  let postalCode: any = undefined;
  let streetNumber: any = undefined;
  let premisesAddress: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ postalCode, streetNumber, premisesAddress,  } = params[0] as MatchAddressQueryParameters);
      options = params[1];
    } else {
      [postalCode, streetNumber, premisesAddress, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FileResponse, TError, TSelectData>({
    queryFn: __matchAddress,
    queryKey: matchAddressQueryKey(postalCode, streetNumber, premisesAddress),
    ...matchAddressDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Find the best matching listing for an address
 * @param postalCode Postal code of the property, e.g., '85251'
 * @param streetNumber Street number of the property, e.g., '8507'
 * @param premisesAddress Full premises address, e.g., '8507 EMONTECyTO Avenue Scottsdale, Arizona 85251'
 * @return OK
 */
export function setMatchAddressData(queryClient: QueryClient, updater: (data: Types.FileResponse | undefined) => Types.FileResponse, postalCode: string, streetNumber: string, premisesAddress: string) {
  queryClient.setQueryData(matchAddressQueryKey(postalCode, streetNumber, premisesAddress),
    updater
  );
}

/**
 * Find the best matching listing for an address
 * @param postalCode Postal code of the property, e.g., '85251'
 * @param streetNumber Street number of the property, e.g., '8507'
 * @param premisesAddress Full premises address, e.g., '8507 EMONTECyTO Avenue Scottsdale, Arizona 85251'
 * @return OK
 */
export function setMatchAddressDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileResponse | undefined) => Types.FileResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getItemByIdUrl(mlsId: string): string {
  let url_ = getBaseUrl() + "/v1/mls/item/{mlsId}";
if (mlsId === undefined || mlsId === null)
  throw new Error("The parameter 'mlsId' must be defined.");
url_ = url_.replace("{mlsId}", encodeURIComponent("" + mlsId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getItemByIdDefaultOptions: Omit<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryFn'>> = {
};
export function getGetItemByIdDefaultOptions() {
  return getItemByIdDefaultOptions;
};
export function setGetItemByIdDefaultOptions(options: typeof getItemByIdDefaultOptions) {
  getItemByIdDefaultOptions = options;
}

export function getItemByIdQueryKey(mlsId: string): QueryKey;
export function getItemByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { mlsId,  } = params[0] as GetItemByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getItemById',
        mlsId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getItemById',
        ...params
      ]);
  }
}
export function __getItemById(context: QueryFunctionContext) {
  return Client().getItemById(
      context.queryKey[2] as string    );
}

export function useGetItemByIdQuery<TSelectData = Types.FileResponse, TError = unknown>(dto: GetItemByIdQueryParameters, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Retrieve MLS listing details by ID
 * @param mlsId Unique MLS ID of the listing in the Spark system
 * @return OK
 */
export function useGetItemByIdQuery<TSelectData = Types.FileResponse, TError = unknown>(mlsId: string, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetItemByIdQuery<TSelectData = Types.FileResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileResponse, TError, TSelectData> | undefined = undefined;
  let mlsId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ mlsId,  } = params[0] as GetItemByIdQueryParameters);
      options = params[1];
    } else {
      [mlsId, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FileResponse, TError, TSelectData>({
    queryFn: __getItemById,
    queryKey: getItemByIdQueryKey(mlsId),
    ...getItemByIdDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Retrieve MLS listing details by ID
 * @param mlsId Unique MLS ID of the listing in the Spark system
 * @return OK
 */
export function setGetItemByIdData(queryClient: QueryClient, updater: (data: Types.FileResponse | undefined) => Types.FileResponse, mlsId: string) {
  queryClient.setQueryData(getItemByIdQueryKey(mlsId),
    updater
  );
}

/**
 * Retrieve MLS listing details by ID
 * @param mlsId Unique MLS ID of the listing in the Spark system
 * @return OK
 */
export function setGetItemByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileResponse | undefined) => Types.FileResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getTemplatesUrl(code: string, templateType: Types.TemplateType2 | undefined): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions/{code}/templates?";
if (code === undefined || code === null)
  throw new Error("The parameter 'code' must be defined.");
url_ = url_.replace("{code}", encodeURIComponent("" + code));
if (templateType === null)
    throw new Error("The parameter 'templateType' cannot be null.");
else if (templateType !== undefined)
    url_ += "templateType=" + encodeURIComponent("" + templateType) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getTemplatesDefaultOptions: Omit<UseQueryOptions<Types.TemplateListDto[], unknown, Types.TemplateListDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.TemplateListDto[], unknown, Types.TemplateListDto[]>, 'queryFn'>> = {
};
export function getGetTemplatesDefaultOptions() {
  return getTemplatesDefaultOptions;
};
export function setGetTemplatesDefaultOptions(options: typeof getTemplatesDefaultOptions) {
  getTemplatesDefaultOptions = options;
}

export function getTemplatesQueryKey(dto: GetTemplatesQueryParameters): QueryKey;
export function getTemplatesQueryKey(code: string, templateType: Types.TemplateType2 | undefined): QueryKey;
export function getTemplatesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { code, templateType,  } = params[0] as GetTemplatesQueryParameters;

    return trimArrayEnd([
        'Client',
        'getTemplates',
        code as any,
        templateType as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getTemplates',
        ...params
      ]);
  }
}
export function __getTemplates(context: QueryFunctionContext) {
  return Client().getTemplates(
      context.queryKey[2] as string,       context.queryKey[3] as Types.TemplateType2 | undefined    );
}

export function useGetTemplatesQuery<TSelectData = Types.TemplateListDto[], TError = unknown>(dto: GetTemplatesQueryParameters, options?: Omit<UseQueryOptions<Types.TemplateListDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List templates for a jurisdiction
 * @param code Jurisdiction code (e.g., CA, TX)
 * @param templateType (optional) Optional template type filter
 * @return List of templates retrieved successfully
 */
export function useGetTemplatesQuery<TSelectData = Types.TemplateListDto[], TError = unknown>(code: string, templateType: Types.TemplateType2 | undefined, options?: Omit<UseQueryOptions<Types.TemplateListDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetTemplatesQuery<TSelectData = Types.TemplateListDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.TemplateListDto[], TError, TSelectData> | undefined = undefined;
  let code: any = undefined;
  let templateType: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ code, templateType,  } = params[0] as GetTemplatesQueryParameters);
      options = params[1];
    } else {
      [code, templateType, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.TemplateListDto[], TError, TSelectData>({
    queryFn: __getTemplates,
    queryKey: getTemplatesQueryKey(code, templateType),
    ...getTemplatesDefaultOptions as unknown as Omit<UseQueryOptions<Types.TemplateListDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List templates for a jurisdiction
 * @param code Jurisdiction code (e.g., CA, TX)
 * @param templateType (optional) Optional template type filter
 * @return List of templates retrieved successfully
 */
export function setGetTemplatesData(queryClient: QueryClient, updater: (data: Types.TemplateListDto[] | undefined) => Types.TemplateListDto[], code: string, templateType: Types.TemplateType2 | undefined) {
  queryClient.setQueryData(getTemplatesQueryKey(code, templateType),
    updater
  );
}

/**
 * List templates for a jurisdiction
 * @param code Jurisdiction code (e.g., CA, TX)
 * @param templateType (optional) Optional template type filter
 * @return List of templates retrieved successfully
 */
export function setGetTemplatesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.TemplateListDto[] | undefined) => Types.TemplateListDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getMlsFieldsUrl(code: string): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions/{code}/mls-fields";
if (code === undefined || code === null)
  throw new Error("The parameter 'code' must be defined.");
url_ = url_.replace("{code}", encodeURIComponent("" + code));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getMlsFieldsDefaultOptions: Omit<UseQueryOptions<string[], unknown, string[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string[], unknown, string[]>, 'queryFn'>> = {
};
export function getGetMlsFieldsDefaultOptions() {
  return getMlsFieldsDefaultOptions;
};
export function setGetMlsFieldsDefaultOptions(options: typeof getMlsFieldsDefaultOptions) {
  getMlsFieldsDefaultOptions = options;
}

export function getMlsFieldsQueryKey(code: string): QueryKey;
export function getMlsFieldsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { code,  } = params[0] as GetMlsFieldsQueryParameters;

    return trimArrayEnd([
        'Client',
        'getMlsFields',
        code as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getMlsFields',
        ...params
      ]);
  }
}
export function __getMlsFields(context: QueryFunctionContext) {
  return Client().getMlsFields(
      context.queryKey[2] as string    );
}

export function useGetMlsFieldsQuery<TSelectData = string[], TError = unknown>(dto: GetMlsFieldsQueryParameters, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get available MLS fields
 * @param code Jurisdiction code (e.g., CA, TX)
 * @return List of MLS fields retrieved successfully
 */
export function useGetMlsFieldsQuery<TSelectData = string[], TError = unknown>(code: string, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetMlsFieldsQuery<TSelectData = string[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string[], TError, TSelectData> | undefined = undefined;
  let code: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ code,  } = params[0] as GetMlsFieldsQueryParameters);
      options = params[1];
    } else {
      [code, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string[], TError, TSelectData>({
    queryFn: __getMlsFields,
    queryKey: getMlsFieldsQueryKey(code),
    ...getMlsFieldsDefaultOptions as unknown as Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get available MLS fields
 * @param code Jurisdiction code (e.g., CA, TX)
 * @return List of MLS fields retrieved successfully
 */
export function setGetMlsFieldsData(queryClient: QueryClient, updater: (data: string[] | undefined) => string[], code: string) {
  queryClient.setQueryData(getMlsFieldsQueryKey(code),
    updater
  );
}

/**
 * Get available MLS fields
 * @param code Jurisdiction code (e.g., CA, TX)
 * @return List of MLS fields retrieved successfully
 */
export function setGetMlsFieldsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string[] | undefined) => string[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getMlsFieldStructureUrl(code: string, fieldName: string): string {
  let url_ = getBaseUrl() + "/v1/jurisdictions/{code}/mls-fields/{fieldName}/structure";
if (code === undefined || code === null)
  throw new Error("The parameter 'code' must be defined.");
url_ = url_.replace("{code}", encodeURIComponent("" + code));
if (fieldName === undefined || fieldName === null)
  throw new Error("The parameter 'fieldName' must be defined.");
url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getMlsFieldStructureDefaultOptions: Omit<UseQueryOptions<{ [key: string]: any; }, unknown, { [key: string]: any; }>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<{ [key: string]: any; }, unknown, { [key: string]: any; }>, 'queryFn'>> = {
};
export function getGetMlsFieldStructureDefaultOptions() {
  return getMlsFieldStructureDefaultOptions;
};
export function setGetMlsFieldStructureDefaultOptions(options: typeof getMlsFieldStructureDefaultOptions) {
  getMlsFieldStructureDefaultOptions = options;
}

export function getMlsFieldStructureQueryKey(dto: GetMlsFieldStructureQueryParameters): QueryKey;
export function getMlsFieldStructureQueryKey(code: string, fieldName: string): QueryKey;
export function getMlsFieldStructureQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { code, fieldName,  } = params[0] as GetMlsFieldStructureQueryParameters;

    return trimArrayEnd([
        'Client',
        'getMlsFieldStructure',
        code as any,
        fieldName as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getMlsFieldStructure',
        ...params
      ]);
  }
}
export function __getMlsFieldStructure(context: QueryFunctionContext) {
  return Client().getMlsFieldStructure(
      context.queryKey[2] as string,       context.queryKey[3] as string    );
}

export function useGetMlsFieldStructureQuery<TSelectData = { [key: string]: any; }, TError = unknown>(dto: GetMlsFieldStructureQueryParameters, options?: Omit<UseQueryOptions<{ [key: string]: any; }, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get MLS field structure
 * @param code Jurisdiction code (e.g., CA, TX)
 * @param fieldName MLS field name
 * @return MLS field structure retrieved successfully
 */
export function useGetMlsFieldStructureQuery<TSelectData = { [key: string]: any; }, TError = unknown>(code: string, fieldName: string, options?: Omit<UseQueryOptions<{ [key: string]: any; }, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetMlsFieldStructureQuery<TSelectData = { [key: string]: any; }, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<{ [key: string]: any; }, TError, TSelectData> | undefined = undefined;
  let code: any = undefined;
  let fieldName: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ code, fieldName,  } = params[0] as GetMlsFieldStructureQueryParameters);
      options = params[1];
    } else {
      [code, fieldName, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<{ [key: string]: any; }, TError, TSelectData>({
    queryFn: __getMlsFieldStructure,
    queryKey: getMlsFieldStructureQueryKey(code, fieldName),
    ...getMlsFieldStructureDefaultOptions as unknown as Omit<UseQueryOptions<{ [key: string]: any; }, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get MLS field structure
 * @param code Jurisdiction code (e.g., CA, TX)
 * @param fieldName MLS field name
 * @return MLS field structure retrieved successfully
 */
export function setGetMlsFieldStructureData(queryClient: QueryClient, updater: (data: { [key: string]: any; } | undefined) => { [key: string]: any; }, code: string, fieldName: string) {
  queryClient.setQueryData(getMlsFieldStructureQueryKey(code, fieldName),
    updater
  );
}

/**
 * Get MLS field structure
 * @param code Jurisdiction code (e.g., CA, TX)
 * @param fieldName MLS field name
 * @return MLS field structure retrieved successfully
 */
export function setGetMlsFieldStructureDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: { [key: string]: any; } | undefined) => { [key: string]: any; }) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getGuestCounterOfferUrl(id: string, x_Guest_Token: string): string {
  let url_ = getBaseUrl() + "/v1/guest/counteroffers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getGuestCounterOfferDefaultOptions: Omit<UseQueryOptions<Types.CounterOfferDto, unknown, Types.CounterOfferDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CounterOfferDto, unknown, Types.CounterOfferDto>, 'queryFn'>> = {
};
export function getGetGuestCounterOfferDefaultOptions() {
  return getGuestCounterOfferDefaultOptions;
};
export function setGetGuestCounterOfferDefaultOptions(options: typeof getGuestCounterOfferDefaultOptions) {
  getGuestCounterOfferDefaultOptions = options;
}

export function getGuestCounterOfferQueryKey(dto: GetGuestCounterOfferQueryParameters): QueryKey;
export function getGuestCounterOfferQueryKey(x_Guest_Token: string, id: string): QueryKey;
export function getGuestCounterOfferQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { x_Guest_Token, id,  } = params[0] as GetGuestCounterOfferQueryParameters;

    return trimArrayEnd([
        'Client',
        'getGuestCounterOffer',
        x_Guest_Token as any,
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getGuestCounterOffer',
        ...params
      ]);
  }
}
export function __getGuestCounterOffer(context: QueryFunctionContext) {
  return Client().getGuestCounterOffer(
      context.queryKey[2] as string,       context.queryKey[3] as string    );
}

export function useGetGuestCounterOfferQuery<TSelectData = Types.CounterOfferDto, TError = unknown>(dto: GetGuestCounterOfferQueryParameters, options?: Omit<UseQueryOptions<Types.CounterOfferDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get counter offer details as guest
 * @param id Counter offer ID
 * @return OK
 */
export function useGetGuestCounterOfferQuery<TSelectData = Types.CounterOfferDto, TError = unknown>(x_Guest_Token: string, id: string, options?: Omit<UseQueryOptions<Types.CounterOfferDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetGuestCounterOfferQuery<TSelectData = Types.CounterOfferDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CounterOfferDto, TError, TSelectData> | undefined = undefined;
  let x_Guest_Token: any = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ x_Guest_Token, id,  } = params[0] as GetGuestCounterOfferQueryParameters);
      options = params[1];
    } else {
      [x_Guest_Token, id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CounterOfferDto, TError, TSelectData>({
    queryFn: __getGuestCounterOffer,
    queryKey: getGuestCounterOfferQueryKey(x_Guest_Token, id),
    ...getGuestCounterOfferDefaultOptions as unknown as Omit<UseQueryOptions<Types.CounterOfferDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get counter offer details as guest
 * @param id Counter offer ID
 * @return OK
 */
export function setGetGuestCounterOfferData(queryClient: QueryClient, updater: (data: Types.CounterOfferDto | undefined) => Types.CounterOfferDto, x_Guest_Token: string, id: string) {
  queryClient.setQueryData(getGuestCounterOfferQueryKey(x_Guest_Token, id),
    updater
  );
}

/**
 * Get counter offer details as guest
 * @param id Counter offer ID
 * @return OK
 */
export function setGetGuestCounterOfferDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CounterOfferDto | undefined) => Types.CounterOfferDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getGuestContractViewUrl(x_Guest_Token: string): string {
  let url_ = getBaseUrl() + "/v1/guest/contract-view";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getGuestContractViewDefaultOptions: Omit<UseQueryOptions<Types.GuestContractViewDto, unknown, Types.GuestContractViewDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.GuestContractViewDto, unknown, Types.GuestContractViewDto>, 'queryFn'>> = {
};
export function getGetGuestContractViewDefaultOptions() {
  return getGuestContractViewDefaultOptions;
};
export function setGetGuestContractViewDefaultOptions(options: typeof getGuestContractViewDefaultOptions) {
  getGuestContractViewDefaultOptions = options;
}

export function getGuestContractViewQueryKey(x_Guest_Token: string): QueryKey;
export function getGuestContractViewQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { x_Guest_Token,  } = params[0] as GetGuestContractViewQueryParameters;

    return trimArrayEnd([
        'Client',
        'getGuestContractView',
        x_Guest_Token as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getGuestContractView',
        ...params
      ]);
  }
}
export function __getGuestContractView(context: QueryFunctionContext) {
  return Client().getGuestContractView(
      context.queryKey[2] as string    );
}

export function useGetGuestContractViewQuery<TSelectData = Types.GuestContractViewDto, TError = unknown>(dto: GetGuestContractViewQueryParameters, options?: Omit<UseQueryOptions<Types.GuestContractViewDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get contract view for guest
 * @return OK
 */
export function useGetGuestContractViewQuery<TSelectData = Types.GuestContractViewDto, TError = unknown>(x_Guest_Token: string, options?: Omit<UseQueryOptions<Types.GuestContractViewDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetGuestContractViewQuery<TSelectData = Types.GuestContractViewDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GuestContractViewDto, TError, TSelectData> | undefined = undefined;
  let x_Guest_Token: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ x_Guest_Token,  } = params[0] as GetGuestContractViewQueryParameters);
      options = params[1];
    } else {
      [x_Guest_Token, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.GuestContractViewDto, TError, TSelectData>({
    queryFn: __getGuestContractView,
    queryKey: getGuestContractViewQueryKey(x_Guest_Token),
    ...getGuestContractViewDefaultOptions as unknown as Omit<UseQueryOptions<Types.GuestContractViewDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get contract view for guest
 * @return OK
 */
export function setGetGuestContractViewData(queryClient: QueryClient, updater: (data: Types.GuestContractViewDto | undefined) => Types.GuestContractViewDto, x_Guest_Token: string) {
  queryClient.setQueryData(getGuestContractViewQueryKey(x_Guest_Token),
    updater
  );
}

/**
 * Get contract view for guest
 * @return OK
 */
export function setGetGuestContractViewDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GuestContractViewDto | undefined) => Types.GuestContractViewDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getExtractionsUrl(userId: string | undefined, callId: string | undefined): string {
  let url_ = getBaseUrl() + "/v1/extractions?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
if (callId === null)
    throw new Error("The parameter 'callId' cannot be null.");
else if (callId !== undefined)
    url_ += "callId=" + encodeURIComponent("" + callId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getExtractionsDefaultOptions: Omit<UseQueryOptions<Types.ExtractionResponse[], unknown, Types.ExtractionResponse[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ExtractionResponse[], unknown, Types.ExtractionResponse[]>, 'queryFn'>> = {
};
export function getGetExtractionsDefaultOptions() {
  return getExtractionsDefaultOptions;
};
export function setGetExtractionsDefaultOptions(options: typeof getExtractionsDefaultOptions) {
  getExtractionsDefaultOptions = options;
}

export function getExtractionsQueryKey(dto: GetExtractionsQueryParameters): QueryKey;
export function getExtractionsQueryKey(userId: string | undefined, callId: string | undefined): QueryKey;
export function getExtractionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { userId, callId,  } = params[0] as GetExtractionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'getExtractions',
        userId as any,
        callId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getExtractions',
        ...params
      ]);
  }
}
export function __getExtractions(context: QueryFunctionContext) {
  return Client().getExtractions(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined    );
}

export function useGetExtractionsQuery<TSelectData = Types.ExtractionResponse[], TError = unknown>(dto: GetExtractionsQueryParameters, options?: Omit<UseQueryOptions<Types.ExtractionResponse[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get extracted data
 * @param userId (optional) 
 * @param callId (optional) 
 * @return OK
 */
export function useGetExtractionsQuery<TSelectData = Types.ExtractionResponse[], TError = unknown>(userId: string | undefined, callId: string | undefined, options?: Omit<UseQueryOptions<Types.ExtractionResponse[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetExtractionsQuery<TSelectData = Types.ExtractionResponse[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ExtractionResponse[], TError, TSelectData> | undefined = undefined;
  let userId: any = undefined;
  let callId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ userId, callId,  } = params[0] as GetExtractionsQueryParameters);
      options = params[1];
    } else {
      [userId, callId, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ExtractionResponse[], TError, TSelectData>({
    queryFn: __getExtractions,
    queryKey: getExtractionsQueryKey(userId, callId),
    ...getExtractionsDefaultOptions as unknown as Omit<UseQueryOptions<Types.ExtractionResponse[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get extracted data
 * @param userId (optional) 
 * @param callId (optional) 
 * @return OK
 */
export function setGetExtractionsData(queryClient: QueryClient, updater: (data: Types.ExtractionResponse[] | undefined) => Types.ExtractionResponse[], userId: string | undefined, callId: string | undefined) {
  queryClient.setQueryData(getExtractionsQueryKey(userId, callId),
    updater
  );
}

/**
 * Get extracted data
 * @param userId (optional) 
 * @param callId (optional) 
 * @return OK
 */
export function setGetExtractionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ExtractionResponse[] | undefined) => Types.ExtractionResponse[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getLatestExtractionUrl(userId: string | undefined): string {
  let url_ = getBaseUrl() + "/v1/extractions/latest?";
if (userId === null)
    throw new Error("The parameter 'userId' cannot be null.");
else if (userId !== undefined)
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getLatestExtractionDefaultOptions: Omit<UseQueryOptions<{ [key: string]: any; }, unknown, { [key: string]: any; }>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<{ [key: string]: any; }, unknown, { [key: string]: any; }>, 'queryFn'>> = {
};
export function getGetLatestExtractionDefaultOptions() {
  return getLatestExtractionDefaultOptions;
};
export function setGetLatestExtractionDefaultOptions(options: typeof getLatestExtractionDefaultOptions) {
  getLatestExtractionDefaultOptions = options;
}

export function getLatestExtractionQueryKey(userId: string | undefined): QueryKey;
export function getLatestExtractionQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { userId,  } = params[0] as GetLatestExtractionQueryParameters;

    return trimArrayEnd([
        'Client',
        'getLatestExtraction',
        userId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getLatestExtraction',
        ...params
      ]);
  }
}
export function __getLatestExtraction(context: QueryFunctionContext) {
  return Client().getLatestExtraction(
      context.queryKey[2] as string | undefined    );
}

export function useGetLatestExtractionQuery<TSelectData = { [key: string]: any; }, TError = unknown>(dto: GetLatestExtractionQueryParameters, options?: Omit<UseQueryOptions<{ [key: string]: any; }, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get latest extraction
 * @param userId (optional) 
 * @return OK
 */
export function useGetLatestExtractionQuery<TSelectData = { [key: string]: any; }, TError = unknown>(userId: string | undefined, options?: Omit<UseQueryOptions<{ [key: string]: any; }, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetLatestExtractionQuery<TSelectData = { [key: string]: any; }, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<{ [key: string]: any; }, TError, TSelectData> | undefined = undefined;
  let userId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ userId,  } = params[0] as GetLatestExtractionQueryParameters);
      options = params[1];
    } else {
      [userId, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<{ [key: string]: any; }, TError, TSelectData>({
    queryFn: __getLatestExtraction,
    queryKey: getLatestExtractionQueryKey(userId),
    ...getLatestExtractionDefaultOptions as unknown as Omit<UseQueryOptions<{ [key: string]: any; }, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get latest extraction
 * @param userId (optional) 
 * @return OK
 */
export function setGetLatestExtractionData(queryClient: QueryClient, updater: (data: { [key: string]: any; } | undefined) => { [key: string]: any; }, userId: string | undefined) {
  queryClient.setQueryData(getLatestExtractionQueryKey(userId),
    updater
  );
}

/**
 * Get latest extraction
 * @param userId (optional) 
 * @return OK
 */
export function setGetLatestExtractionDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: { [key: string]: any; } | undefined) => { [key: string]: any; }) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function listAllDocumentsUrl(): string {
  let url_ = getBaseUrl() + "/v1/documents";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let listAllDocumentsDefaultOptions: Omit<UseQueryOptions<Types.DocumentListDto[], unknown, Types.DocumentListDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DocumentListDto[], unknown, Types.DocumentListDto[]>, 'queryFn'>> = {
};
export function getListAllDocumentsDefaultOptions() {
  return listAllDocumentsDefaultOptions;
};
export function setListAllDocumentsDefaultOptions(options: typeof listAllDocumentsDefaultOptions) {
  listAllDocumentsDefaultOptions = options;
}

export function listAllDocumentsQueryKey(): QueryKey;
export function listAllDocumentsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'listAllDocuments',
    ]);
}
export function __listAllDocuments(context: QueryFunctionContext) {
  return Client().listAllDocuments(
    );
}

/**
 * List all documents
 * @return OK
 */
export function useListAllDocumentsQuery<TSelectData = Types.DocumentListDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.DocumentListDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useListAllDocumentsQuery<TSelectData = Types.DocumentListDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DocumentListDto[], TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DocumentListDto[], TError, TSelectData>({
    queryFn: __listAllDocuments,
    queryKey: listAllDocumentsQueryKey(),
    ...listAllDocumentsDefaultOptions as unknown as Omit<UseQueryOptions<Types.DocumentListDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List all documents
 * @return OK
 */
export function setListAllDocumentsData(queryClient: QueryClient, updater: (data: Types.DocumentListDto[] | undefined) => Types.DocumentListDto[], ) {
  queryClient.setQueryData(listAllDocumentsQueryKey(),
    updater
  );
}

/**
 * List all documents
 * @return OK
 */
export function setListAllDocumentsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DocumentListDto[] | undefined) => Types.DocumentListDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getDocumentUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/documents/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getDocumentDefaultOptions: Omit<UseQueryOptions<Types.DocumentDetailDto, unknown, Types.DocumentDetailDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DocumentDetailDto, unknown, Types.DocumentDetailDto>, 'queryFn'>> = {
};
export function getGetDocumentDefaultOptions() {
  return getDocumentDefaultOptions;
};
export function setGetDocumentDefaultOptions(options: typeof getDocumentDefaultOptions) {
  getDocumentDefaultOptions = options;
}

export function getDocumentQueryKey(id: string): QueryKey;
export function getDocumentQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetDocumentQueryParameters;

    return trimArrayEnd([
        'Client',
        'getDocument',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getDocument',
        ...params
      ]);
  }
}
export function __getDocument(context: QueryFunctionContext) {
  return Client().getDocument(
      context.queryKey[2] as string    );
}

export function useGetDocumentQuery<TSelectData = Types.DocumentDetailDto, TError = unknown>(dto: GetDocumentQueryParameters, options?: Omit<UseQueryOptions<Types.DocumentDetailDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get document details
 * @param id Document ID
 * @return OK
 */
export function useGetDocumentQuery<TSelectData = Types.DocumentDetailDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.DocumentDetailDto, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetDocumentQuery<TSelectData = Types.DocumentDetailDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DocumentDetailDto, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetDocumentQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DocumentDetailDto, TError, TSelectData>({
    queryFn: __getDocument,
    queryKey: getDocumentQueryKey(id),
    ...getDocumentDefaultOptions as unknown as Omit<UseQueryOptions<Types.DocumentDetailDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get document details
 * @param id Document ID
 * @return OK
 */
export function setGetDocumentData(queryClient: QueryClient, updater: (data: Types.DocumentDetailDto | undefined) => Types.DocumentDetailDto, id: string) {
  queryClient.setQueryData(getDocumentQueryKey(id),
    updater
  );
}

/**
 * Get document details
 * @param id Document ID
 * @return OK
 */
export function setGetDocumentDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DocumentDetailDto | undefined) => Types.DocumentDetailDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getContractsByAgentUrl(userId: string): string {
  let url_ = getBaseUrl() + "/v1/documents/by-agent?";
  if (userId === undefined || userId === null)
    throw new Error("The parameter 'userId' must be defined and cannot be null.");
  else
    url_ += "userId=" + encodeURIComponent("" + userId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getContractsByAgentDefaultOptions: Omit<UseQueryOptions<Types.ContractByJurisdictionDto[], unknown, Types.ContractByJurisdictionDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ContractByJurisdictionDto[], unknown, Types.ContractByJurisdictionDto[]>, 'queryFn'>> = {
};
export function getGetContractsByAgentDefaultOptions() {
  return getContractsByAgentDefaultOptions;
};
export function setGetContractsByAgentDefaultOptions(options: typeof getContractsByAgentDefaultOptions) {
  getContractsByAgentDefaultOptions = options;
}

export function getContractsByAgentQueryKey(userId: string): QueryKey;
export function getContractsByAgentQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { userId,  } = params[0] as GetContractsByAgentQueryParameters;

    return trimArrayEnd([
        'Client',
        'getContractsByAgent',
        userId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getContractsByAgent',
        ...params
      ]);
  }
}
export function __getContractsByAgent(context: QueryFunctionContext) {
  return Client().getContractsByAgent(
      context.queryKey[2] as string    );
}

export function useGetContractsByAgentQuery<TSelectData = Types.ContractByJurisdictionDto[], TError = unknown>(dto: GetContractsByAgentQueryParameters, options?: Omit<UseQueryOptions<Types.ContractByJurisdictionDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get contracts by user
 * @param userId User ID (Clerk ID)
 * @return OK
 */
export function useGetContractsByAgentQuery<TSelectData = Types.ContractByJurisdictionDto[], TError = unknown>(userId: string, options?: Omit<UseQueryOptions<Types.ContractByJurisdictionDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetContractsByAgentQuery<TSelectData = Types.ContractByJurisdictionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ContractByJurisdictionDto[], TError, TSelectData> | undefined = undefined;
  let userId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ userId,  } = params[0] as GetContractsByAgentQueryParameters);
      options = params[1];
    } else {
      [userId, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ContractByJurisdictionDto[], TError, TSelectData>({
    queryFn: __getContractsByAgent,
    queryKey: getContractsByAgentQueryKey(userId),
    ...getContractsByAgentDefaultOptions as unknown as Omit<UseQueryOptions<Types.ContractByJurisdictionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get contracts by user
 * @param userId User ID (Clerk ID)
 * @return OK
 */
export function setGetContractsByAgentData(queryClient: QueryClient, updater: (data: Types.ContractByJurisdictionDto[] | undefined) => Types.ContractByJurisdictionDto[], userId: string) {
  queryClient.setQueryData(getContractsByAgentQueryKey(userId),
    updater
  );
}

/**
 * Get contracts by user
 * @param userId User ID (Clerk ID)
 * @return OK
 */
export function setGetContractsByAgentDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ContractByJurisdictionDto[] | undefined) => Types.ContractByJurisdictionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPdfmeLayoutUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/pdfme-layout";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPdfmeLayoutDefaultOptions: Omit<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryFn'>> = {
};
export function getGetPdfmeLayoutDefaultOptions() {
  return getPdfmeLayoutDefaultOptions;
};
export function setGetPdfmeLayoutDefaultOptions(options: typeof getPdfmeLayoutDefaultOptions) {
  getPdfmeLayoutDefaultOptions = options;
}

export function getPdfmeLayoutQueryKey(id: string): QueryKey;
export function getPdfmeLayoutQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetPdfmeLayoutQueryParameters;

    return trimArrayEnd([
        'Client',
        'getPdfmeLayout',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getPdfmeLayout',
        ...params
      ]);
  }
}
export function __getPdfmeLayout(context: QueryFunctionContext) {
  return Client().getPdfmeLayout(
      context.queryKey[2] as string    );
}

export function useGetPdfmeLayoutQuery<TSelectData = Types.FileResponse, TError = unknown>(dto: GetPdfmeLayoutQueryParameters, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * Get pdfme layout for deal
 * @param id Deal ID
 * @return OK
 */
export function useGetPdfmeLayoutQuery<TSelectData = Types.FileResponse, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetPdfmeLayoutQuery<TSelectData = Types.FileResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileResponse, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetPdfmeLayoutQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FileResponse, TError, TSelectData>({
    queryFn: __getPdfmeLayout,
    queryKey: getPdfmeLayoutQueryKey(id),
    ...getPdfmeLayoutDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get pdfme layout for deal
 * @param id Deal ID
 * @return OK
 */
export function setGetPdfmeLayoutData(queryClient: QueryClient, updater: (data: Types.FileResponse | undefined) => Types.FileResponse, id: string) {
  queryClient.setQueryData(getPdfmeLayoutQueryKey(id),
    updater
  );
}

/**
 * Get pdfme layout for deal
 * @param id Deal ID
 * @return OK
 */
export function setGetPdfmeLayoutDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileResponse | undefined) => Types.FileResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getAddendaUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/deals/{id}/addenda";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAddendaDefaultOptions: Omit<UseQueryOptions<Types.AddendumItemDto[], unknown, Types.AddendumItemDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AddendumItemDto[], unknown, Types.AddendumItemDto[]>, 'queryFn'>> = {
};
export function getGetAddendaDefaultOptions() {
  return getAddendaDefaultOptions;
};
export function setGetAddendaDefaultOptions(options: typeof getAddendaDefaultOptions) {
  getAddendaDefaultOptions = options;
}

export function getAddendaQueryKey(id: string): QueryKey;
export function getAddendaQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetAddendaQueryParameters;

    return trimArrayEnd([
        'Client',
        'getAddenda',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getAddenda',
        ...params
      ]);
  }
}
export function __getAddenda(context: QueryFunctionContext) {
  return Client().getAddenda(
      context.queryKey[2] as string    );
}

export function useGetAddendaQuery<TSelectData = Types.AddendumItemDto[], TError = unknown>(dto: GetAddendaQueryParameters, options?: Omit<UseQueryOptions<Types.AddendumItemDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * List addenda for a deal
 * @param id Deal ID
 * @return OK
 */
export function useGetAddendaQuery<TSelectData = Types.AddendumItemDto[], TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.AddendumItemDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetAddendaQuery<TSelectData = Types.AddendumItemDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AddendumItemDto[], TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetAddendaQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AddendumItemDto[], TError, TSelectData>({
    queryFn: __getAddenda,
    queryKey: getAddendaQueryKey(id),
    ...getAddendaDefaultOptions as unknown as Omit<UseQueryOptions<Types.AddendumItemDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List addenda for a deal
 * @param id Deal ID
 * @return OK
 */
export function setGetAddendaData(queryClient: QueryClient, updater: (data: Types.AddendumItemDto[] | undefined) => Types.AddendumItemDto[], id: string) {
  queryClient.setQueryData(getAddendaQueryKey(id),
    updater
  );
}

/**
 * List addenda for a deal
 * @param id Deal ID
 * @return OK
 */
export function setGetAddendaDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AddendumItemDto[] | undefined) => Types.AddendumItemDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getSignedDocumentsUrl(): string {
  let url_ = getBaseUrl() + "/v1/admin/documents/signed";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getSignedDocumentsDefaultOptions: Omit<UseQueryOptions<Types.DocumentDetailDto[], unknown, Types.DocumentDetailDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DocumentDetailDto[], unknown, Types.DocumentDetailDto[]>, 'queryFn'>> = {
};
export function getGetSignedDocumentsDefaultOptions() {
  return getSignedDocumentsDefaultOptions;
};
export function setGetSignedDocumentsDefaultOptions(options: typeof getSignedDocumentsDefaultOptions) {
  getSignedDocumentsDefaultOptions = options;
}

export function getSignedDocumentsQueryKey(): QueryKey;
export function getSignedDocumentsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getSignedDocuments',
    ]);
}
export function __getSignedDocuments(context: QueryFunctionContext) {
  return Client().getSignedDocuments(
    );
}

/**
 * Get all signed documents
 * @return OK
 */
export function useGetSignedDocumentsQuery<TSelectData = Types.DocumentDetailDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.DocumentDetailDto[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetSignedDocumentsQuery<TSelectData = Types.DocumentDetailDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DocumentDetailDto[], TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DocumentDetailDto[], TError, TSelectData>({
    queryFn: __getSignedDocuments,
    queryKey: getSignedDocumentsQueryKey(),
    ...getSignedDocumentsDefaultOptions as unknown as Omit<UseQueryOptions<Types.DocumentDetailDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get all signed documents
 * @return OK
 */
export function setGetSignedDocumentsData(queryClient: QueryClient, updater: (data: Types.DocumentDetailDto[] | undefined) => Types.DocumentDetailDto[], ) {
  queryClient.setQueryData(getSignedDocumentsQueryKey(),
    updater
  );
}

/**
 * Get all signed documents
 * @return OK
 */
export function setGetSignedDocumentsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DocumentDetailDto[] | undefined) => Types.DocumentDetailDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function deleteTemplateUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/templates/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteTemplateMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteTemplate',
      id as any,
    ]);
}

/**
 * Delete template (soft delete)
 * @param id Template ID
 * @return OK
 */
export function useDeleteTemplateMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteTemplateMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteTemplate(id),
    mutationKey: key,
  });
}
  
type DeleteTemplate__MutationParameters = DeleteTemplateQueryParameters

/**
 * Delete template (soft delete)
 * @param id Template ID
 * @return OK
 */
export function useDeleteTemplateMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteTemplate__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteTemplateQueryParameters}): UseMutationResult<void, unknown, DeleteTemplate__MutationParameters, TContext> {
  const key = deleteTemplateMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteTemplate__MutationParameters) => Client().deleteTemplate(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function revokeGuestLinkUrl(linkId: string): string {
  let url_ = getBaseUrl() + "/v1/guest-links/{linkId}";
if (linkId === undefined || linkId === null)
  throw new Error("The parameter 'linkId' must be defined.");
url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function revokeGuestLinkMutationKey(linkId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'revokeGuestLink',
      linkId as any,
    ]);
}

/**
 * Revoke guest link
 * @return OK
 */
export function useRevokeGuestLinkMutation<TContext>(linkId: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = revokeGuestLinkMutationKey(linkId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().revokeGuestLink(linkId),
    mutationKey: key,
  });
}
  
type RevokeGuestLink__MutationParameters = RevokeGuestLinkQueryParameters

/**
 * Revoke guest link
 * @return OK
 */
export function useRevokeGuestLinkMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, RevokeGuestLink__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RevokeGuestLinkQueryParameters}): UseMutationResult<void, unknown, RevokeGuestLink__MutationParameters, TContext> {
  const key = revokeGuestLinkMutationKey(options?.parameters?.linkId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: RevokeGuestLink__MutationParameters) => Client().revokeGuestLink(data.linkId ?? options?.parameters?.linkId!),
  mutationKey: key,
});
}
  
export function deleteDocumentUrl(id: string): string {
  let url_ = getBaseUrl() + "/v1/admin/documents/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteDocumentMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteDocument',
      id as any,
    ]);
}

/**
 * Delete a document
 * @return OK
 */
export function useDeleteDocumentMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteDocumentMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteDocument(id),
    mutationKey: key,
  });
}
  
type DeleteDocument__MutationParameters = DeleteDocumentQueryParameters

/**
 * Delete a document
 * @return OK
 */
export function useDeleteDocumentMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteDocument__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteDocumentQueryParameters}): UseMutationResult<void, unknown, DeleteDocument__MutationParameters, TContext> {
  const key = deleteDocumentMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteDocument__MutationParameters) => Client().deleteDocument(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}