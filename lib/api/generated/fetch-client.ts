//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

//-----ClientClass--Client---
export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080/api";
    }

    /**
     * Update template slug
     * @param id Template ID
     * @return OK
     */
    updateSlug(id: string, body: TemplateSlugUpdateRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/templates/{id}/slug";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSlug(_response);
        });
    }

    protected processUpdateSlug(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update prompts for the latest DRAFT version
     * @return OK
     */
    updatePrompts(id: string, body: ContractTemplateUpdateRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/templates/{id}/prompts";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePrompts(_response);
        });
    }

    protected processUpdatePrompts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update PDFME layout
     * @param id Template ID
     * @return OK
     */
    updatePdfmeLayout(id: string, body: PdfmeLayoutUpdateRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/templates/{id}/pdfme-layout";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePdfmeLayout(_response);
        });
    }

    protected processUpdatePdfmeLayout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get current user profile
     * @return OK
     */
    getCurrentUserProfile(): Promise<UserResponseDTO> {
        let url_ = this.baseUrl + "/v1/profile/me";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserProfile(_response);
        });
    }

    protected processGetCurrentUserProfile(response: Response): Promise<UserResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResponseDTO>(null as any);
    }

    /**
     * Update user profile
     * @return OK
     */
    updateCurrentUserProfile(body: OnboardingRequestDTO): Promise<UserResponseDTO> {
        let url_ = this.baseUrl + "/v1/profile/me";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCurrentUserProfile(_response);
        });
    }

    protected processUpdateCurrentUserProfile(response: Response): Promise<UserResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResponseDTO>(null as any);
    }

    /**
     * Get a jurisdiction by ID
     * @return Jurisdiction retrieved
     */
    getJurisdictionById(id: string): Promise<JurisdictionResponseDto> {
        let url_ = this.baseUrl + "/v1/jurisdictions/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJurisdictionById(_response);
        });
    }

    protected processGetJurisdictionById(response: Response): Promise<JurisdictionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JurisdictionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = JurisdictionResponseDto.fromJS(resultData404);
            return throwException("Jurisdiction not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JurisdictionResponseDto>(null as any);
    }

    /**
     * Update a jurisdiction
     * @return Jurisdiction updated
     */
    updateJurisdiction(id: string, body: JurisdictionRequestDto): Promise<JurisdictionResponseDto> {
        let url_ = this.baseUrl + "/v1/jurisdictions/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateJurisdiction(_response);
        });
    }

    protected processUpdateJurisdiction(response: Response): Promise<JurisdictionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JurisdictionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = JurisdictionResponseDto.fromJS(resultData404);
            return throwException("Jurisdiction not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JurisdictionResponseDto>(null as any);
    }

    /**
     * Delete a jurisdiction (soft delete)
     * @return Jurisdiction soft deleted
     */
    deleteJurisdiction(id: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/jurisdictions/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteJurisdiction(_response);
        });
    }

    protected processDeleteJurisdiction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Jurisdiction not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update document status
     * @param id Document ID
     * @return OK
     */
    updateDocumentStatus(id: string, body: DocumentStatusUpdateRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/documents/{id}/status";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDocumentStatus(_response);
        });
    }

    protected processUpdateDocumentStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get deal details
     * @param id Deal ID
     * @return OK
     */
    getDeal(id: string): Promise<DealDetailDto> {
        let url_ = this.baseUrl + "/v1/deals/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeal(_response);
        });
    }

    protected processGetDeal(response: Response): Promise<DealDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealDetailDto>(null as any);
    }

    /**
     * Update a deal
     * @param id Deal ID
     * @return OK
     */
    updateDeal(id: string, body: DealUpdateRequest): Promise<DealDetailDto> {
        let url_ = this.baseUrl + "/v1/deals/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDeal(_response);
        });
    }

    protected processUpdateDeal(response: Response): Promise<DealDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealDetailDto>(null as any);
    }

    /**
     * Delete a deal (soft delete)
     * @param id Deal ID
     * @return OK
     */
    deleteDeal(id: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/deals/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDeal(_response);
        });
    }

    protected processDeleteDeal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get contract data for deal
     * @param id Deal ID
     * @return OK
     */
    getContractData(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/deals/{id}/contract-data";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractData(_response);
        });
    }

    protected processGetContractData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Save contract data for deal
     * @param id Deal ID
     * @return OK
     */
    saveContractData(id: string, body: JsonNode): Promise<void> {
        let url_ = this.baseUrl + "/v1/deals/{id}/contract-data";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveContractData(_response);
        });
    }

    protected processSaveContractData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Process Retell webhook
     * @return OK
     */
    handleRetellWebhook(body: string): Promise<string> {
        let url_ = this.baseUrl + "/v1/webhooks/retell";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleRetellWebhook(_response);
        });
    }

    protected processHandleRetellWebhook(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Process DocuSign webhook
     * @param x_DocuSign_Signature_1 (optional) 
     * @return OK
     */
    handleDocuSignEvent(x_DocuSign_Signature_1: string | undefined, body: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/webhooks/docusign";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-DocuSign-Signature-1": x_DocuSign_Signature_1 !== undefined && x_DocuSign_Signature_1 !== null ? "" + x_DocuSign_Signature_1 : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleDocuSignEvent(_response);
        });
    }

    protected processHandleDocuSignEvent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param svix_id (optional) 
     * @param svix_timestamp (optional) 
     * @param svix_signature (optional) 
     * @return OK
     */
    handleWebhook(svix_id: string | undefined, svix_timestamp: string | undefined, svix_signature: string | undefined, body: string): Promise<string> {
        let url_ = this.baseUrl + "/v1/webhooks/clerk";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "svix-id": svix_id !== undefined && svix_id !== null ? "" + svix_id : "",
                "svix-timestamp": svix_timestamp !== undefined && svix_timestamp !== null ? "" + svix_timestamp : "",
                "svix-signature": svix_signature !== undefined && svix_signature !== null ? "" + svix_signature : "",
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleWebhook(_response);
        });
    }

    protected processHandleWebhook(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Create a new contract template
     * @return OK
     */
    create(body: ContractTemplateCreateRequest): Promise<string> {
        let url_ = this.baseUrl + "/v1/templates";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Publish template version
     * @return OK
     */
    publish(id: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/templates/{id}/publish";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Regenerate all prompts
     * @return OK
     */
    regenerateAllPrompts(): Promise<string> {
        let url_ = this.baseUrl + "/v1/templates/regenerate-prompts";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegenerateAllPrompts(_response);
        });
    }

    protected processRegenerateAllPrompts(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Initialize prompt
     * @return OK
     */
    initPrompt(body: string): Promise<PromptInitResponse> {
        let url_ = this.baseUrl + "/v1/prompt-init";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitPrompt(_response);
        });
    }

    protected processInitPrompt(response: Response): Promise<PromptInitResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromptInitResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromptInitResponse>(null as any);
    }

    /**
     * Initialize extraction prompt
     * @return OK
     */
    initExtractionPrompt(body: PromptInitRequest): Promise<PromptInitResponse> {
        let url_ = this.baseUrl + "/v1/prompt-extraction";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitExtractionPrompt(_response);
        });
    }

    protected processInitExtractionPrompt(response: Response): Promise<PromptInitResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromptInitResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromptInitResponse>(null as any);
    }

    /**
     * Complete agent onboarding
     * @return OK
     */
    completeOnboarding(body: OnboardingRequestDTO): Promise<UserResponseDTO> {
        let url_ = this.baseUrl + "/v1/onboarding";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteOnboarding(_response);
        });
    }

    protected processCompleteOnboarding(response: Response): Promise<UserResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResponseDTO>(null as any);
    }

    /**
     * Get all active jurisdictions
     * @return List of jurisdictions retrieved successfully
     */
    getAllJurisdictions(): Promise<JurisdictionResponseDto[]> {
        let url_ = this.baseUrl + "/v1/jurisdictions";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJurisdictions(_response);
        });
    }

    protected processGetAllJurisdictions(response: Response): Promise<JurisdictionResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JurisdictionResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JurisdictionResponseDto[]>(null as any);
    }

    /**
     * Create a new jurisdiction
     * @return Jurisdiction created
     */
    createJurisdiction(body: JurisdictionRequestDto): Promise<JurisdictionResponseDto> {
        let url_ = this.baseUrl + "/v1/jurisdictions";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateJurisdiction(_response);
        });
    }

    protected processCreateJurisdiction(response: Response): Promise<JurisdictionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JurisdictionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = JurisdictionResponseDto.fromJS(resultData400);
            return throwException("Invalid input / duplicate code", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JurisdictionResponseDto>(null as any);
    }

    /**
     * Process Retell instance webhook
     * @return OK
     */
    handleInstanceWebhook(body: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/instance-webhook";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleInstanceWebhook(_response);
        });
    }

    protected processHandleInstanceWebhook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Validate guest token
     * @return OK
     */
    validateGuestToken(body: string): Promise<GuestLinkDto> {
        let url_ = this.baseUrl + "/v1/guest/validate";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateGuestToken(_response);
        });
    }

    protected processValidateGuestToken(response: Response): Promise<GuestLinkDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GuestLinkDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuestLinkDto>(null as any);
    }

    /**
     * List counter offers as guest
     * @return OK
     */
    listGuestCounterOffers(x_Guest_Token: string): Promise<CounterOfferDto[]> {
        let url_ = this.baseUrl + "/v1/guest/counteroffers";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Guest-Token": x_Guest_Token !== undefined && x_Guest_Token !== null ? "" + x_Guest_Token : "",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListGuestCounterOffers(_response);
        });
    }

    protected processListGuestCounterOffers(response: Response): Promise<CounterOfferDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterOfferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto[]>(null as any);
    }

    /**
     * Create a counter offer as guest
     * @return Counter offer created
     */
    createGuestCounterOffer(x_Guest_Token: string, body: CounterOfferCreateRequest): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/guest/counteroffers";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Guest-Token": x_Guest_Token !== undefined && x_Guest_Token !== null ? "" + x_Guest_Token : "",
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGuestCounterOffer(_response);
        });
    }

    protected processCreateGuestCounterOffer(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CounterOfferDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Upload PDF for counter offer as guest
     * @param id Counter offer ID
     * @param body (optional) 
     * @return OK
     */
    uploadGuestCounterOfferPdf(x_Guest_Token: string, id: string, body: Body | undefined): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/guest/counteroffers/{id}/upload";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Guest-Token": x_Guest_Token !== undefined && x_Guest_Token !== null ? "" + x_Guest_Token : "",
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadGuestCounterOfferPdf(_response);
        });
    }

    protected processUploadGuestCounterOfferPdf(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterOfferDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Get fields by jurisdiction
     * @return OK
     */
    getFields(body: GetFieldsRequest): Promise<GetFieldsByJurisdictionResponse> {
        let url_ = this.baseUrl + "/v1/get-fields";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFields(_response);
        });
    }

    protected processGetFields(response: Response): Promise<GetFieldsByJurisdictionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFieldsByJurisdictionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetFieldsByJurisdictionResponse>(null as any);
    }

    /**
     * Send document for signature
     * @param documentId Document ID
     * @return OK
     */
    sendForSignature(documentId: string, body: SendForSignatureRequestDTO): Promise<SignatureResponseDTO> {
        let url_ = this.baseUrl + "/v1/documents/{documentId}/send-for-signature";
        if (documentId === undefined || documentId === null)
          throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendForSignature(_response);
        });
    }

    protected processSendForSignature(response: Response): Promise<SignatureResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignatureResponseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SignatureResponseDTO>(null as any);
    }

    /**
     * Send document review email
     * @param documentId Document ID
     * @return OK
     */
    sendEmail(documentId: string, body: SendEmailRequestDTO): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/documents/{documentId}/send-email";
        if (documentId === undefined || documentId === null)
          throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendEmail(_response);
        });
    }

    protected processSendEmail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * List documents for a deal
     * @param dealId Deal ID
     * @return OK
     */
    listDocuments(dealId: string): Promise<DocumentListDto[]> {
        let url_ = this.baseUrl + "/v1/documents/deals/{dealId}";
        if (dealId === undefined || dealId === null)
          throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListDocuments(_response);
        });
    }

    protected processListDocuments(response: Response): Promise<DocumentListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentListDto[]>(null as any);
    }

    /**
     * Create a new document
     * @param dealId Deal ID
     * @return OK
     */
    createDocument(dealId: string, body: DocumentCreateRequest): Promise<DocumentDetailDto> {
        let url_ = this.baseUrl + "/v1/documents/deals/{dealId}";
        if (dealId === undefined || dealId === null)
          throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDocument(_response);
        });
    }

    protected processCreateDocument(response: Response): Promise<DocumentDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDetailDto>(null as any);
    }

    /**
     * List deals with pagination and filtering
     * @param status (optional) Filter by status: DRAFT, WAITING_SIGNATURE, COMPLETED, BLOCKED
     * @param search (optional) Search by address, buyer name, seller name, or MLS ID
     * @param limit (optional) Number of results per page (default: 50)
     * @param offset (optional) Pagination offset (default: 0)
     * @param docType (optional) Filter by document type: CONTRACT, BBA, ADDENDUM, etc. Only deals with at least one document of this type are returned.
     * @return OK
     */
    listDeals(status: string | undefined, search: string | undefined, limit: number | undefined, offset: number | undefined, docType: string | undefined): Promise<DealListResponseDto> {
        let url_ = this.baseUrl + "/v1/deals?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (docType === null)
            throw new Error("The parameter 'docType' cannot be null.");
        else if (docType !== undefined)
            url_ += "docType=" + encodeURIComponent("" + docType) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListDeals(_response);
        });
    }

    protected processListDeals(response: Response): Promise<DealListResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealListResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealListResponseDto>(null as any);
    }

    /**
     * Create a new deal
     * @return OK
     */
    createDeal(body: DealCreateRequest): Promise<DealDetailDto> {
        let url_ = this.baseUrl + "/v1/deals";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDeal(_response);
        });
    }

    protected processCreateDeal(response: Response): Promise<DealDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealDetailDto>(null as any);
    }

    /**
     * List guest links
     * @return OK
     */
    listGuestLinks(id: string): Promise<GuestLinkDto[]> {
        let url_ = this.baseUrl + "/v1/deals/{id}/guest-links";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListGuestLinks(_response);
        });
    }

    protected processListGuestLinks(response: Response): Promise<GuestLinkDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuestLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuestLinkDto[]>(null as any);
    }

    /**
     * Create a guest link
     * @return OK
     */
    createGuestLink(id: string, body: GuestLinkCreateRequest): Promise<GuestLinkDto> {
        let url_ = this.baseUrl + "/v1/deals/{id}/guest-links";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGuestLink(_response);
        });
    }

    protected processCreateGuestLink(response: Response): Promise<GuestLinkDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GuestLinkDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuestLinkDto>(null as any);
    }

    /**
     * List counter offers for a deal
     * @param id Deal ID
     * @return OK
     */
    listCounterOffers(id: string): Promise<CounterOfferDto[]> {
        let url_ = this.baseUrl + "/v1/deals/{id}/counteroffers";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListCounterOffers(_response);
        });
    }

    protected processListCounterOffers(response: Response): Promise<CounterOfferDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterOfferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto[]>(null as any);
    }

    /**
     * Create a counter offer
     * @param id Deal ID
     * @return Counter offer created
     */
    createCounterOffer(id: string, body: CounterOfferCreateRequest): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/deals/{id}/counteroffers";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCounterOffer(_response);
        });
    }

    protected processCreateCounterOffer(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CounterOfferDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Upload signed PDF for counter offer
     * @param id Counter offer ID
     * @param body (optional) 
     * @return OK
     */
    uploadCounterOfferPdf(id: string, body: Body2 | undefined): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/counteroffers/{id}/upload";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadCounterOfferPdf(_response);
        });
    }

    protected processUploadCounterOfferPdf(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterOfferDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Search BBA by buyer name
     * @return OK
     */
    searchBbaByBuyerName(body: BbaSearchRequest): Promise<BbaSearchResponse> {
        let url_ = this.baseUrl + "/v1/bba/search";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchBbaByBuyerName(_response);
        });
    }

    protected processSearchBbaByBuyerName(response: Response): Promise<BbaSearchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BbaSearchResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BbaSearchResponse>(null as any);
    }

    /**
     * Get counter offer details
     * @param id Counter offer ID
     * @return OK
     */
    getCounterOffer(id: string): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/counteroffers/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCounterOffer(_response);
        });
    }

    protected processGetCounterOffer(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterOfferDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Delete a counter offer (soft delete)
     * @param id Counter offer ID
     * @return OK
     */
    deleteCounterOffer(id: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/counteroffers/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCounterOffer(_response);
        });
    }

    protected processDeleteCounterOffer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update a counter offer
     * @param id Counter offer ID
     * @return OK
     */
    updateCounterOffer(id: string, body: CounterOfferUpdateRequest): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/counteroffers/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCounterOffer(_response);
        });
    }

    protected processUpdateCounterOffer(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterOfferDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Get template version by status
     * @param id Template ID
     * @param status Version status
     * @return OK
     */
    getTemplateVersionById(id: string, status: Status): Promise<ContractTemplateVersionDto> {
        let url_ = this.baseUrl + "/v1/templates/{id}/prompts/{status}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
          throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateVersionById(_response);
        });
    }

    protected processGetTemplateVersionById(response: Response): Promise<ContractTemplateVersionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTemplateVersionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractTemplateVersionDto>(null as any);
    }

    /**
     * Get PDFME layout
     * @param id Template ID
     * @param status Version status
     * @return OK
     */
    getTemplatePdfmeLayout(id: string, status: Status2): Promise<PdfmeLayoutUpdateRequest> {
        let url_ = this.baseUrl + "/v1/templates/{id}/pdfme-layout/{status}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
          throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplatePdfmeLayout(_response);
        });
    }

    protected processGetTemplatePdfmeLayout(response: Response): Promise<PdfmeLayoutUpdateRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfmeLayoutUpdateRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PdfmeLayoutUpdateRequest>(null as any);
    }

    /**
     * Get All template versions by status
     * @param status Version status
     * @return OK
     */
    getAllTemplateVersions(status: Status3): Promise<ContractTemplateVersionDto[]> {
        let url_ = this.baseUrl + "/v1/templates/list/{status}";
        if (status === undefined || status === null)
          throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTemplateVersions(_response);
        });
    }

    protected processGetAllTemplateVersions(response: Response): Promise<ContractTemplateVersionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractTemplateVersionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractTemplateVersionDto[]>(null as any);
    }

    /**
     * Find or auto-create template
     * @param jurisdictionCode Jurisdiction code (e.g., CA, TX)
     * @param templateType Template type
     * @param slug (optional) Slug for ADDENDA templates (required for ADDENDA)
     * @return OK
     */
    findOrCreateTemplate(jurisdictionCode: string, templateType: TemplateType, slug: string | undefined): Promise<ContractTemplateVersionDto> {
        let url_ = this.baseUrl + "/v1/templates/find?";
          if (jurisdictionCode === undefined || jurisdictionCode === null)
            throw new Error("The parameter 'jurisdictionCode' must be defined and cannot be null.");
          else
            url_ += "jurisdictionCode=" + encodeURIComponent("" + jurisdictionCode) + "&";
          if (templateType === undefined || templateType === null)
            throw new Error("The parameter 'templateType' must be defined and cannot be null.");
          else
            url_ += "templateType=" + encodeURIComponent("" + templateType) + "&";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindOrCreateTemplate(_response);
        });
    }

    protected processFindOrCreateTemplate(response: Response): Promise<ContractTemplateVersionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTemplateVersionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractTemplateVersionDto>(null as any);
    }

    /**
     * Get addendum PDFME layout by slug and userId
     * @param addendumSlug Addendum slug (e.g. hoa, solar-addendum)
     * @param userId (optional) User ID (clerkId) - used to determine jurisdiction. Falls back to auth principal if not provided.
     * @param status (optional) Version status
     * @return OK
     */
    getAddendumPdfmeLayout(addendumSlug: string, userId: string | undefined, status: Status4 | undefined): Promise<PdfmeLayoutUpdateRequest> {
        let url_ = this.baseUrl + "/v1/templates/addendum/{addendumSlug}/pdfme-layout?";
        if (addendumSlug === undefined || addendumSlug === null)
          throw new Error("The parameter 'addendumSlug' must be defined.");
        url_ = url_.replace("{addendumSlug}", encodeURIComponent("" + addendumSlug));
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAddendumPdfmeLayout(_response);
        });
    }

    protected processGetAddendumPdfmeLayout(response: Response): Promise<PdfmeLayoutUpdateRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfmeLayoutUpdateRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PdfmeLayoutUpdateRequest>(null as any);
    }

    /**
     * Find the best matching listing for an address
     * @param postalCode Postal code of the property, e.g., '85251'
     * @param streetNumber Street number of the property, e.g., '8507'
     * @param premisesAddress Full premises address, e.g., '8507 EMONTECyTO Avenue Scottsdale, Arizona 85251'
     * @return OK
     */
    matchAddress(postalCode: string, streetNumber: string, premisesAddress: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/mls/match?";
          if (postalCode === undefined || postalCode === null)
            throw new Error("The parameter 'postalCode' must be defined and cannot be null.");
          else
            url_ += "postalCode=" + encodeURIComponent("" + postalCode) + "&";
          if (streetNumber === undefined || streetNumber === null)
            throw new Error("The parameter 'streetNumber' must be defined and cannot be null.");
          else
            url_ += "streetNumber=" + encodeURIComponent("" + streetNumber) + "&";
          if (premisesAddress === undefined || premisesAddress === null)
            throw new Error("The parameter 'premisesAddress' must be defined and cannot be null.");
          else
            url_ += "premisesAddress=" + encodeURIComponent("" + premisesAddress) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMatchAddress(_response);
        });
    }

    protected processMatchAddress(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Retrieve MLS listing details by ID
     * @param mlsId Unique MLS ID of the listing in the Spark system
     * @return OK
     */
    getItemById(mlsId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/mls/item/{mlsId}";
        if (mlsId === undefined || mlsId === null)
          throw new Error("The parameter 'mlsId' must be defined.");
        url_ = url_.replace("{mlsId}", encodeURIComponent("" + mlsId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetItemById(_response);
        });
    }

    protected processGetItemById(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * List templates for a jurisdiction
     * @param code Jurisdiction code (e.g., CA, TX)
     * @param templateType (optional) Optional template type filter
     * @return List of templates retrieved successfully
     */
    getTemplates(code: string, templateType: TemplateType2 | undefined): Promise<TemplateListDto[]> {
        let url_ = this.baseUrl + "/v1/jurisdictions/{code}/templates?";
        if (code === undefined || code === null)
          throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        if (templateType === null)
            throw new Error("The parameter 'templateType' cannot be null.");
        else if (templateType !== undefined)
            url_ += "templateType=" + encodeURIComponent("" + templateType) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: Response): Promise<TemplateListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateListDto[]>(null as any);
    }

    /**
     * Get available MLS fields
     * @param code Jurisdiction code (e.g., CA, TX)
     * @return List of MLS fields retrieved successfully
     */
    getMlsFields(code: string): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/jurisdictions/{code}/mls-fields";
        if (code === undefined || code === null)
          throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMlsFields(_response);
        });
    }

    protected processGetMlsFields(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Get MLS field structure
     * @param code Jurisdiction code (e.g., CA, TX)
     * @param fieldName MLS field name
     * @return MLS field structure retrieved successfully
     */
    getMlsFieldStructure(code: string, fieldName: string): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/v1/jurisdictions/{code}/mls-fields/{fieldName}/structure";
        if (code === undefined || code === null)
          throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        if (fieldName === undefined || fieldName === null)
          throw new Error("The parameter 'fieldName' must be defined.");
        url_ = url_.replace("{fieldName}", encodeURIComponent("" + fieldName));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMlsFieldStructure(_response);
        });
    }

    protected processGetMlsFieldStructure(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData404) {
                result404 = {} as any;
                for (let key in resultData404) {
                    if (resultData404.hasOwnProperty(key))
                        (<any>result404)![key] = resultData404[key] !== undefined ? resultData404[key] : <any>null;
                }
            }
            else {
                result404 = <any>null;
            }
            return throwException("MLS field not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }

    /**
     * Get counter offer details as guest
     * @param id Counter offer ID
     * @return OK
     */
    getGuestCounterOffer(x_Guest_Token: string, id: string): Promise<CounterOfferDto> {
        let url_ = this.baseUrl + "/v1/guest/counteroffers/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Guest-Token": x_Guest_Token !== undefined && x_Guest_Token !== null ? "" + x_Guest_Token : "",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGuestCounterOffer(_response);
        });
    }

    protected processGetGuestCounterOffer(response: Response): Promise<CounterOfferDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterOfferDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterOfferDto>(null as any);
    }

    /**
     * Get contract view for guest
     * @return OK
     */
    getGuestContractView(x_Guest_Token: string): Promise<GuestContractViewDto> {
        let url_ = this.baseUrl + "/v1/guest/contract-view";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Guest-Token": x_Guest_Token !== undefined && x_Guest_Token !== null ? "" + x_Guest_Token : "",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGuestContractView(_response);
        });
    }

    protected processGetGuestContractView(response: Response): Promise<GuestContractViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GuestContractViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuestContractViewDto>(null as any);
    }

    /**
     * Get extracted data
     * @param userId (optional) 
     * @param callId (optional) 
     * @return OK
     */
    getExtractions(userId: string | undefined, callId: string | undefined): Promise<ExtractionResponse[]> {
        let url_ = this.baseUrl + "/v1/extractions?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (callId === null)
            throw new Error("The parameter 'callId' cannot be null.");
        else if (callId !== undefined)
            url_ += "callId=" + encodeURIComponent("" + callId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExtractions(_response);
        });
    }

    protected processGetExtractions(response: Response): Promise<ExtractionResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExtractionResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtractionResponse[]>(null as any);
    }

    /**
     * Get latest extraction
     * @param userId (optional) 
     * @return OK
     */
    getLatestExtraction(userId: string | undefined): Promise<{ [key: string]: any; }> {
        let url_ = this.baseUrl + "/v1/extractions/latest?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLatestExtraction(_response);
        });
    }

    protected processGetLatestExtraction(response: Response): Promise<{ [key: string]: any; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: any; }>(null as any);
    }

    /**
     * List all documents
     * @return OK
     */
    listAllDocuments(): Promise<DocumentListDto[]> {
        let url_ = this.baseUrl + "/v1/documents";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListAllDocuments(_response);
        });
    }

    protected processListAllDocuments(response: Response): Promise<DocumentListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentListDto[]>(null as any);
    }

    /**
     * Get document details
     * @param id Document ID
     * @return OK
     */
    getDocument(id: string): Promise<DocumentDetailDto> {
        let url_ = this.baseUrl + "/v1/documents/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocument(_response);
        });
    }

    protected processGetDocument(response: Response): Promise<DocumentDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDetailDto>(null as any);
    }

    /**
     * Get contracts by user
     * @param userId User ID (Clerk ID)
     * @return OK
     */
    getContractsByAgent(userId: string): Promise<ContractByJurisdictionDto[]> {
        let url_ = this.baseUrl + "/v1/documents/by-agent?";
          if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
          else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractsByAgent(_response);
        });
    }

    protected processGetContractsByAgent(response: Response): Promise<ContractByJurisdictionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractByJurisdictionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractByJurisdictionDto[]>(null as any);
    }

    /**
     * Get pdfme layout for deal
     * @param id Deal ID
     * @return OK
     */
    getPdfmeLayout(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/deals/{id}/pdfme-layout";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPdfmeLayout(_response);
        });
    }

    protected processGetPdfmeLayout(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * List addenda for a deal
     * @param id Deal ID
     * @return OK
     */
    getAddenda(id: string): Promise<AddendumItemDto[]> {
        let url_ = this.baseUrl + "/v1/deals/{id}/addenda";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAddenda(_response);
        });
    }

    protected processGetAddenda(response: Response): Promise<AddendumItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddendumItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddendumItemDto[]>(null as any);
    }

    /**
     * Get all signed documents
     * @return OK
     */
    getSignedDocuments(): Promise<DocumentDetailDto[]> {
        let url_ = this.baseUrl + "/v1/admin/documents/signed";
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSignedDocuments(_response);
        });
    }

    protected processGetSignedDocuments(response: Response): Promise<DocumentDetailDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDetailDto[]>(null as any);
    }

    /**
     * Delete template (soft delete)
     * @param id Template ID
     * @return OK
     */
    deleteTemplate(id: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/templates/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplate(_response);
        });
    }

    protected processDeleteTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Revoke guest link
     * @return OK
     */
    revokeGuestLink(linkId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/guest-links/{linkId}";
        if (linkId === undefined || linkId === null)
          throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevokeGuestLink(_response);
        });
    }

    protected processRevokeGuestLink(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a document
     * @return OK
     */
    deleteDocument(id: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/admin/documents/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDocument(_response);
        });
    }

    protected processDeleteDocument(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}
//-----/ClientClass----




//-----Types.File-----
export class TemplateSlugUpdateRequest implements ITemplateSlugUpdateRequest {
    /** New slug value for the template */
    slug!: string;

    [key: string]: any;

    constructor(data?: ITemplateSlugUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): TemplateSlugUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSlugUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["slug"] = this.slug;
        return data;
    }
}

export interface ITemplateSlugUpdateRequest {
    /** New slug value for the template */
    slug: string;

    [key: string]: any;
}

export class ContractTemplateUpdateRequest implements IContractTemplateUpdateRequest {
    /** Unique ID of the Contract template */
    id?: string;
    slug?: string;
    title?: string;
    documentPrompt!: string;

    [key: string]: any;

    constructor(data?: IContractTemplateUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.documentPrompt = _data["documentPrompt"];
        }
    }

    static fromJS(data: any): ContractTemplateUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTemplateUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["documentPrompt"] = this.documentPrompt;
        return data;
    }
}

export interface IContractTemplateUpdateRequest {
    /** Unique ID of the Contract template */
    id?: string;
    slug?: string;
    title?: string;
    documentPrompt: string;

    [key: string]: any;
}

export class JsonNode implements IJsonNode {

    [key: string]: any;

    constructor(data?: IJsonNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): JsonNode {
        data = typeof data === 'object' ? data : {};
        let result = new JsonNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IJsonNode {

    [key: string]: any;
}

export class PdfmeLayoutUpdateRequest implements IPdfmeLayoutUpdateRequest {
    /** Unique ID of the Contract template */
    id?: string;
    pdfmeLayout!: JsonNode;

    [key: string]: any;

    constructor(data?: IPdfmeLayoutUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.pdfmeLayout = new JsonNode();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.pdfmeLayout = _data["pdfmeLayout"] ? JsonNode.fromJS(_data["pdfmeLayout"]) : new JsonNode();
        }
    }

    static fromJS(data: any): PdfmeLayoutUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PdfmeLayoutUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["pdfmeLayout"] = this.pdfmeLayout ? this.pdfmeLayout.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPdfmeLayoutUpdateRequest {
    /** Unique ID of the Contract template */
    id?: string;
    pdfmeLayout: JsonNode;

    [key: string]: any;
}

export class OnboardingRequestDTO implements IOnboardingRequestDTO {
    firstName?: string;
    lastName?: string;
    licenseNumber?: string;
    stateLicenseNumbers?: string;
    mlsCode?: string;
    mlsId?: string;
    firmName?: string;
    firmAddressStreet?: string;
    firmAddressCity?: string;
    firmAddressState?: string;
    firmAddressZip?: string;
    brokeragePhone?: string;
    brokerageEmail?: string;
    brokerageFax?: string;
    jurisdictionCode?: string;

    [key: string]: any;

    constructor(data?: IOnboardingRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.licenseNumber = _data["licenseNumber"];
            this.stateLicenseNumbers = _data["stateLicenseNumbers"];
            this.mlsCode = _data["mlsCode"];
            this.mlsId = _data["mlsId"];
            this.firmName = _data["firmName"];
            this.firmAddressStreet = _data["firmAddressStreet"];
            this.firmAddressCity = _data["firmAddressCity"];
            this.firmAddressState = _data["firmAddressState"];
            this.firmAddressZip = _data["firmAddressZip"];
            this.brokeragePhone = _data["brokeragePhone"];
            this.brokerageEmail = _data["brokerageEmail"];
            this.brokerageFax = _data["brokerageFax"];
            this.jurisdictionCode = _data["jurisdictionCode"];
        }
    }

    static fromJS(data: any): OnboardingRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["licenseNumber"] = this.licenseNumber;
        data["stateLicenseNumbers"] = this.stateLicenseNumbers;
        data["mlsCode"] = this.mlsCode;
        data["mlsId"] = this.mlsId;
        data["firmName"] = this.firmName;
        data["firmAddressStreet"] = this.firmAddressStreet;
        data["firmAddressCity"] = this.firmAddressCity;
        data["firmAddressState"] = this.firmAddressState;
        data["firmAddressZip"] = this.firmAddressZip;
        data["brokeragePhone"] = this.brokeragePhone;
        data["brokerageEmail"] = this.brokerageEmail;
        data["brokerageFax"] = this.brokerageFax;
        data["jurisdictionCode"] = this.jurisdictionCode;
        return data;
    }
}

export interface IOnboardingRequestDTO {
    firstName?: string;
    lastName?: string;
    licenseNumber?: string;
    stateLicenseNumbers?: string;
    mlsCode?: string;
    mlsId?: string;
    firmName?: string;
    firmAddressStreet?: string;
    firmAddressCity?: string;
    firmAddressState?: string;
    firmAddressZip?: string;
    brokeragePhone?: string;
    brokerageEmail?: string;
    brokerageFax?: string;
    jurisdictionCode?: string;

    [key: string]: any;
}

export class UserResponseDTO implements IUserResponseDTO {
    clerkId?: string;
    email?: string;
    fullName?: string;
    role?: UserResponseDTORole;
    status?: UserResponseDTOStatus;
    onboarded?: boolean;
    firstName?: string;
    lastName?: string;
    licenseNumber?: string;
    stateLicenseNumbers?: string;
    mlsCode?: string;
    mlsId?: string;
    firmName?: string;
    firmAddressStreet?: string;
    firmAddressCity?: string;
    firmAddressState?: string;
    firmAddressZip?: string;
    brokeragePhone?: string;
    brokerageEmail?: string;
    brokerageFax?: string;
    jurisdictionCode?: string;
    profileImageUrl?: string;
    createdAt?: Date;
    lastSyncedAt?: Date;

    [key: string]: any;

    constructor(data?: IUserResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.clerkId = _data["clerkId"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.role = _data["role"];
            this.status = _data["status"];
            this.onboarded = _data["onboarded"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.licenseNumber = _data["licenseNumber"];
            this.stateLicenseNumbers = _data["stateLicenseNumbers"];
            this.mlsCode = _data["mlsCode"];
            this.mlsId = _data["mlsId"];
            this.firmName = _data["firmName"];
            this.firmAddressStreet = _data["firmAddressStreet"];
            this.firmAddressCity = _data["firmAddressCity"];
            this.firmAddressState = _data["firmAddressState"];
            this.firmAddressZip = _data["firmAddressZip"];
            this.brokeragePhone = _data["brokeragePhone"];
            this.brokerageEmail = _data["brokerageEmail"];
            this.brokerageFax = _data["brokerageFax"];
            this.jurisdictionCode = _data["jurisdictionCode"];
            this.profileImageUrl = _data["profileImageUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastSyncedAt = _data["lastSyncedAt"] ? new Date(_data["lastSyncedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["clerkId"] = this.clerkId;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["role"] = this.role;
        data["status"] = this.status;
        data["onboarded"] = this.onboarded;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["licenseNumber"] = this.licenseNumber;
        data["stateLicenseNumbers"] = this.stateLicenseNumbers;
        data["mlsCode"] = this.mlsCode;
        data["mlsId"] = this.mlsId;
        data["firmName"] = this.firmName;
        data["firmAddressStreet"] = this.firmAddressStreet;
        data["firmAddressCity"] = this.firmAddressCity;
        data["firmAddressState"] = this.firmAddressState;
        data["firmAddressZip"] = this.firmAddressZip;
        data["brokeragePhone"] = this.brokeragePhone;
        data["brokerageEmail"] = this.brokerageEmail;
        data["brokerageFax"] = this.brokerageFax;
        data["jurisdictionCode"] = this.jurisdictionCode;
        data["profileImageUrl"] = this.profileImageUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastSyncedAt"] = this.lastSyncedAt ? this.lastSyncedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserResponseDTO {
    clerkId?: string;
    email?: string;
    fullName?: string;
    role?: UserResponseDTORole;
    status?: UserResponseDTOStatus;
    onboarded?: boolean;
    firstName?: string;
    lastName?: string;
    licenseNumber?: string;
    stateLicenseNumbers?: string;
    mlsCode?: string;
    mlsId?: string;
    firmName?: string;
    firmAddressStreet?: string;
    firmAddressCity?: string;
    firmAddressState?: string;
    firmAddressZip?: string;
    brokeragePhone?: string;
    brokerageEmail?: string;
    brokerageFax?: string;
    jurisdictionCode?: string;
    profileImageUrl?: string;
    createdAt?: Date;
    lastSyncedAt?: Date;

    [key: string]: any;
}

export class JurisdictionResponseDto implements IJurisdictionResponseDto {
    /** Unique ID of the jurisdiction */
    id?: string;
    /** Unique code for the jurisdiction */
    code?: string;
    /** Name of the jurisdiction */
    name?: string;

    [key: string]: any;

    constructor(data?: IJurisdictionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JurisdictionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new JurisdictionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface IJurisdictionResponseDto {
    /** Unique ID of the jurisdiction */
    id?: string;
    /** Unique code for the jurisdiction */
    code?: string;
    /** Name of the jurisdiction */
    name?: string;

    [key: string]: any;
}

export class JurisdictionRequestDto implements IJurisdictionRequestDto {
    code!: string;
    name!: string;

    [key: string]: any;

    constructor(data?: IJurisdictionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JurisdictionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new JurisdictionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface IJurisdictionRequestDto {
    code: string;
    name: string;

    [key: string]: any;
}

export class DocumentStatusUpdateRequest implements IDocumentStatusUpdateRequest {
    /** New document status: DRAFT, SENT_FOR_REVIEW, SENT_FOR_SIGNATURE, SIGNED_FINAL */
    status!: string;

    [key: string]: any;

    constructor(data?: IDocumentStatusUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DocumentStatusUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStatusUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        return data;
    }
}

export interface IDocumentStatusUpdateRequest {
    /** New document status: DRAFT, SENT_FOR_REVIEW, SENT_FOR_SIGNATURE, SIGNED_FINAL */
    status: string;

    [key: string]: any;
}

export class DealUpdateRequest implements IDealUpdateRequest {
    /** Address line */
    addressLine?: string;
    /** Full address */
    fullAddress?: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Jurisdiction code */
    jurisdiction?: string;
    /** Deal status */
    status?: string;

    [key: string]: any;

    constructor(data?: IDealUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.addressLine = _data["addressLine"];
            this.fullAddress = _data["fullAddress"];
            this.buyerName = _data["buyerName"];
            this.sellerName = _data["sellerName"];
            this.mlsId = _data["mlsId"];
            this.jurisdiction = _data["jurisdiction"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DealUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["addressLine"] = this.addressLine;
        data["fullAddress"] = this.fullAddress;
        data["buyerName"] = this.buyerName;
        data["sellerName"] = this.sellerName;
        data["mlsId"] = this.mlsId;
        data["jurisdiction"] = this.jurisdiction;
        data["status"] = this.status;
        return data;
    }
}

export interface IDealUpdateRequest {
    /** Address line */
    addressLine?: string;
    /** Full address */
    fullAddress?: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Jurisdiction code */
    jurisdiction?: string;
    /** Deal status */
    status?: string;

    [key: string]: any;
}

export class DealDetailDto implements IDealDetailDto {
    /** Deal ID */
    id?: string;
    /** Address line */
    addressLine?: string;
    /** Full address */
    fullAddress?: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Jurisdiction code */
    jurisdiction?: string;
    /** Deal status */
    status?: string;
    /** Creation timestamp (ISO format) */
    createdAtISO?: Date;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;

    [key: string]: any;

    constructor(data?: IDealDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.addressLine = _data["addressLine"];
            this.fullAddress = _data["fullAddress"];
            this.buyerName = _data["buyerName"];
            this.sellerName = _data["sellerName"];
            this.mlsId = _data["mlsId"];
            this.jurisdiction = _data["jurisdiction"];
            this.status = _data["status"];
            this.createdAtISO = _data["createdAtISO"] ? new Date(_data["createdAtISO"].toString()) : <any>undefined;
            this.updatedAtISO = _data["updatedAtISO"] ? new Date(_data["updatedAtISO"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DealDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["addressLine"] = this.addressLine;
        data["fullAddress"] = this.fullAddress;
        data["buyerName"] = this.buyerName;
        data["sellerName"] = this.sellerName;
        data["mlsId"] = this.mlsId;
        data["jurisdiction"] = this.jurisdiction;
        data["status"] = this.status;
        data["createdAtISO"] = this.createdAtISO ? this.createdAtISO.toISOString() : <any>undefined;
        data["updatedAtISO"] = this.updatedAtISO ? this.updatedAtISO.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDealDetailDto {
    /** Deal ID */
    id?: string;
    /** Address line */
    addressLine?: string;
    /** Full address */
    fullAddress?: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Jurisdiction code */
    jurisdiction?: string;
    /** Deal status */
    status?: string;
    /** Creation timestamp (ISO format) */
    createdAtISO?: Date;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;

    [key: string]: any;
}

export class ContractTemplateCreateRequest implements IContractTemplateCreateRequest {
    jurisdictionCode!: string;
    templateType!: ContractTemplateCreateRequestTemplateType;
    slug?: string;
    title?: string;
    documentPrompt!: string;

    [key: string]: any;

    constructor(data?: IContractTemplateCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.jurisdictionCode = _data["jurisdictionCode"];
            this.templateType = _data["templateType"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.documentPrompt = _data["documentPrompt"];
        }
    }

    static fromJS(data: any): ContractTemplateCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTemplateCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["jurisdictionCode"] = this.jurisdictionCode;
        data["templateType"] = this.templateType;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["documentPrompt"] = this.documentPrompt;
        return data;
    }
}

export interface IContractTemplateCreateRequest {
    jurisdictionCode: string;
    templateType: ContractTemplateCreateRequestTemplateType;
    slug?: string;
    title?: string;
    documentPrompt: string;

    [key: string]: any;
}

export class PromptInitResponse implements IPromptInitResponse {
    prompt?: string;

    [key: string]: any;

    constructor(data?: IPromptInitResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.prompt = _data["prompt"];
        }
    }

    static fromJS(data: any): PromptInitResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PromptInitResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["prompt"] = this.prompt;
        return data;
    }
}

export interface IPromptInitResponse {
    prompt?: string;

    [key: string]: any;
}

export class PromptInitRequest implements IPromptInitRequest {
    type?: string;
    mode?: string;
    address?: string;
    buyerNames?: string;
    userId?: string;
    contractId?: string;
    bbaID?: string;

    [key: string]: any;

    constructor(data?: IPromptInitRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.mode = _data["mode"];
            this.address = _data["address"];
            this.buyerNames = _data["buyerNames"];
            this.userId = _data["userId"];
            this.contractId = _data["contractId"];
            this.bbaID = _data["bbaID"];
        }
    }

    static fromJS(data: any): PromptInitRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PromptInitRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["mode"] = this.mode;
        data["address"] = this.address;
        data["buyerNames"] = this.buyerNames;
        data["userId"] = this.userId;
        data["contractId"] = this.contractId;
        data["bbaID"] = this.bbaID;
        return data;
    }
}

export interface IPromptInitRequest {
    type?: string;
    mode?: string;
    address?: string;
    buyerNames?: string;
    userId?: string;
    contractId?: string;
    bbaID?: string;

    [key: string]: any;
}

export class GuestLinkDto implements IGuestLinkDto {
    /** Guest link ID */
    id?: string;
    /** Magic link token */
    token?: string;
    /** Guest access URL */
    url?: string;
    /** Deal ID */
    contractInstanceId?: string;
    /** Guest email */
    guestEmail?: string;
    /** Guest name */
    guestName?: string;
    /** Expiration timestamp */
    expiresAt?: Date;
    /** First accessed timestamp */
    accessedAt?: Date;
    /** Creation timestamp */
    createdAt?: Date;
    /** Property Address */
    propertyAddress?: string;
    /** Buyer Name */
    buyerName?: string;
    /** Seller Name */
    sellerName?: string;
    /** Guest Role (BUYER, SELLER, or null) */
    guestRole?: string;

    [key: string]: any;

    constructor(data?: IGuestLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.token = _data["token"];
            this.url = _data["url"];
            this.contractInstanceId = _data["contractInstanceId"];
            this.guestEmail = _data["guestEmail"];
            this.guestName = _data["guestName"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.accessedAt = _data["accessedAt"] ? new Date(_data["accessedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.propertyAddress = _data["propertyAddress"];
            this.buyerName = _data["buyerName"];
            this.sellerName = _data["sellerName"];
            this.guestRole = _data["guestRole"];
        }
    }

    static fromJS(data: any): GuestLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuestLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["token"] = this.token;
        data["url"] = this.url;
        data["contractInstanceId"] = this.contractInstanceId;
        data["guestEmail"] = this.guestEmail;
        data["guestName"] = this.guestName;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["accessedAt"] = this.accessedAt ? this.accessedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["propertyAddress"] = this.propertyAddress;
        data["buyerName"] = this.buyerName;
        data["sellerName"] = this.sellerName;
        data["guestRole"] = this.guestRole;
        return data;
    }
}

export interface IGuestLinkDto {
    /** Guest link ID */
    id?: string;
    /** Magic link token */
    token?: string;
    /** Guest access URL */
    url?: string;
    /** Deal ID */
    contractInstanceId?: string;
    /** Guest email */
    guestEmail?: string;
    /** Guest name */
    guestName?: string;
    /** Expiration timestamp */
    expiresAt?: Date;
    /** First accessed timestamp */
    accessedAt?: Date;
    /** Creation timestamp */
    createdAt?: Date;
    /** Property Address */
    propertyAddress?: string;
    /** Buyer Name */
    buyerName?: string;
    /** Seller Name */
    sellerName?: string;
    /** Guest Role (BUYER, SELLER, or null) */
    guestRole?: string;

    [key: string]: any;
}

export class CounterOfferCreateRequest implements ICounterOfferCreateRequest {
    /** Optional ID of a voice session to link to the new counter offer */
    voiceSessionId?: string;
    /** Set to true when buyer agent is creating a counter offer on behalf of the seller */
    onBehalfOfSeller?: boolean;

    [key: string]: any;

    constructor(data?: ICounterOfferCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.voiceSessionId = _data["voiceSessionId"];
            this.onBehalfOfSeller = _data["onBehalfOfSeller"];
        }
    }

    static fromJS(data: any): CounterOfferCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CounterOfferCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["voiceSessionId"] = this.voiceSessionId;
        data["onBehalfOfSeller"] = this.onBehalfOfSeller;
        return data;
    }
}

export interface ICounterOfferCreateRequest {
    /** Optional ID of a voice session to link to the new counter offer */
    voiceSessionId?: string;
    /** Set to true when buyer agent is creating a counter offer on behalf of the seller */
    onBehalfOfSeller?: boolean;

    [key: string]: any;
}

export class CounterOfferDto implements ICounterOfferDto {
    /** Counter offer ID */
    id?: string;
    /** Deal ID */
    contractInstanceId?: string;
    /** Sequence number in the counter chain */
    sequenceNumber?: number;
    /** Side: SELLER or BUYER. If set explicitly via docVariant, uses that value. Otherwise derived from sequence number: odd = SELLER, even = BUYER */
    side?: string;
    /** Voice session ID if created via voice */
    voiceSessionId?: string;
    /** Counter offer field values */
    fieldsJson?: JsonNode;
    /** Draft PDF URL */
    draftPdfUrl?: string;
    /** Uploaded PDF URL */
    uploadedPdfUrl?: string;
    /** Signed PDF URL */
    signedPdfUrl?: string;
    /** E-signature provider envelope ID */
    providerEnvelopeId?: string;
    /** E-signature provider name */
    providerName?: string;
    /** Envelope status from provider */
    envelopeStatus?: string;
    /** When counter was sent for signature */
    sentForSignatureAt?: Date;
    /** When counter was signed */
    signedAt?: Date;
    /** Counter status: DRAFT, OUT_FOR_SIGNATURE, SIGNED, SUPERSEDED */
    status?: string;
    /** How the counter was created */
    creationMethod?: string;
    /** Creation timestamp */
    createdAt?: Date;
    /** Last update timestamp */
    updatedAt?: Date;

    [key: string]: any;

    constructor(data?: ICounterOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.contractInstanceId = _data["contractInstanceId"];
            this.sequenceNumber = _data["sequenceNumber"];
            this.side = _data["side"];
            this.voiceSessionId = _data["voiceSessionId"];
            this.fieldsJson = _data["fieldsJson"] ? JsonNode.fromJS(_data["fieldsJson"]) : <any>undefined;
            this.draftPdfUrl = _data["draftPdfUrl"];
            this.uploadedPdfUrl = _data["uploadedPdfUrl"];
            this.signedPdfUrl = _data["signedPdfUrl"];
            this.providerEnvelopeId = _data["providerEnvelopeId"];
            this.providerName = _data["providerName"];
            this.envelopeStatus = _data["envelopeStatus"];
            this.sentForSignatureAt = _data["sentForSignatureAt"] ? new Date(_data["sentForSignatureAt"].toString()) : <any>undefined;
            this.signedAt = _data["signedAt"] ? new Date(_data["signedAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.creationMethod = _data["creationMethod"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CounterOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["contractInstanceId"] = this.contractInstanceId;
        data["sequenceNumber"] = this.sequenceNumber;
        data["side"] = this.side;
        data["voiceSessionId"] = this.voiceSessionId;
        data["fieldsJson"] = this.fieldsJson ? this.fieldsJson.toJSON() : <any>undefined;
        data["draftPdfUrl"] = this.draftPdfUrl;
        data["uploadedPdfUrl"] = this.uploadedPdfUrl;
        data["signedPdfUrl"] = this.signedPdfUrl;
        data["providerEnvelopeId"] = this.providerEnvelopeId;
        data["providerName"] = this.providerName;
        data["envelopeStatus"] = this.envelopeStatus;
        data["sentForSignatureAt"] = this.sentForSignatureAt ? this.sentForSignatureAt.toISOString() : <any>undefined;
        data["signedAt"] = this.signedAt ? this.signedAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["creationMethod"] = this.creationMethod;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICounterOfferDto {
    /** Counter offer ID */
    id?: string;
    /** Deal ID */
    contractInstanceId?: string;
    /** Sequence number in the counter chain */
    sequenceNumber?: number;
    /** Side: SELLER or BUYER. If set explicitly via docVariant, uses that value. Otherwise derived from sequence number: odd = SELLER, even = BUYER */
    side?: string;
    /** Voice session ID if created via voice */
    voiceSessionId?: string;
    /** Counter offer field values */
    fieldsJson?: JsonNode;
    /** Draft PDF URL */
    draftPdfUrl?: string;
    /** Uploaded PDF URL */
    uploadedPdfUrl?: string;
    /** Signed PDF URL */
    signedPdfUrl?: string;
    /** E-signature provider envelope ID */
    providerEnvelopeId?: string;
    /** E-signature provider name */
    providerName?: string;
    /** Envelope status from provider */
    envelopeStatus?: string;
    /** When counter was sent for signature */
    sentForSignatureAt?: Date;
    /** When counter was signed */
    signedAt?: Date;
    /** Counter status: DRAFT, OUT_FOR_SIGNATURE, SIGNED, SUPERSEDED */
    status?: string;
    /** How the counter was created */
    creationMethod?: string;
    /** Creation timestamp */
    createdAt?: Date;
    /** Last update timestamp */
    updatedAt?: Date;

    [key: string]: any;
}

export class GetFieldsRequest implements IGetFieldsRequest {
    type?: string;
    jurisdictionCode?: string;

    [key: string]: any;

    constructor(data?: IGetFieldsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.jurisdictionCode = _data["jurisdictionCode"];
        }
    }

    static fromJS(data: any): GetFieldsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetFieldsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["jurisdictionCode"] = this.jurisdictionCode;
        return data;
    }
}

export interface IGetFieldsRequest {
    type?: string;
    jurisdictionCode?: string;

    [key: string]: any;
}

/** Fields by jurisdiction response with metadata */
export class GetFieldsByJurisdictionResponse implements IGetFieldsByJurisdictionResponse {
    /** Template version ID */
    id?: string;
    /** When the template version was created */
    createdAt?: Date;
    /** Field key for buyer name (e.g. buyerName, buyerNames) */
    buyerName?: string;
    /** Field key for address (e.g. propertyAddress, address) */
    address?: string;
    /** Map of all field names to their types */
    fields?: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IGetFieldsByJurisdictionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.buyerName = _data["buyerName"];
            this.address = _data["address"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetFieldsByJurisdictionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFieldsByJurisdictionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["buyerName"] = this.buyerName;
        data["address"] = this.address;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = (<any>this.fields)[key];
            }
        }
        return data;
    }
}

/** Fields by jurisdiction response with metadata */
export interface IGetFieldsByJurisdictionResponse {
    /** Template version ID */
    id?: string;
    /** When the template version was created */
    createdAt?: Date;
    /** Field key for buyer name (e.g. buyerName, buyerNames) */
    buyerName?: string;
    /** Field key for address (e.g. propertyAddress, address) */
    address?: string;
    /** Map of all field names to their types */
    fields?: { [key: string]: string; };

    [key: string]: any;
}

export class SendForSignatureRequestDTO implements ISendForSignatureRequestDTO {
    signers!: SignerDTO[];
    emailSubject!: string;
    emailBody?: string;

    [key: string]: any;

    constructor(data?: ISendForSignatureRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.signers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(SignerDTO.fromJS(item));
            }
            this.emailSubject = _data["emailSubject"];
            this.emailBody = _data["emailBody"];
        }
    }

    static fromJS(data: any): SendForSignatureRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SendForSignatureRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        data["emailSubject"] = this.emailSubject;
        data["emailBody"] = this.emailBody;
        return data;
    }
}

export interface ISendForSignatureRequestDTO {
    signers: SignerDTO[];
    emailSubject: string;
    emailBody?: string;

    [key: string]: any;
}

export class SignerDTO implements ISignerDTO {
    email!: string;
    name!: string;
    role!: string;
    routingOrder?: number;
    anchorStrings!: string[];

    [key: string]: any;

    constructor(data?: ISignerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.anchorStrings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.name = _data["name"];
            this.role = _data["role"];
            this.routingOrder = _data["routingOrder"];
            if (Array.isArray(_data["anchorStrings"])) {
                this.anchorStrings = [] as any;
                for (let item of _data["anchorStrings"])
                    this.anchorStrings!.push(item);
            }
        }
    }

    static fromJS(data: any): SignerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SignerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["name"] = this.name;
        data["role"] = this.role;
        data["routingOrder"] = this.routingOrder;
        if (Array.isArray(this.anchorStrings)) {
            data["anchorStrings"] = [];
            for (let item of this.anchorStrings)
                data["anchorStrings"].push(item);
        }
        return data;
    }
}

export interface ISignerDTO {
    email: string;
    name: string;
    role: string;
    routingOrder?: number;
    anchorStrings: string[];

    [key: string]: any;
}

export class SignatureResponseDTO implements ISignatureResponseDTO {
    envelopeId?: string;
    status?: string;
    signingUrl?: string;
    sentAt?: Date;

    [key: string]: any;

    constructor(data?: ISignatureResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.envelopeId = _data["envelopeId"];
            this.status = _data["status"];
            this.signingUrl = _data["signingUrl"];
            this.sentAt = _data["sentAt"] ? new Date(_data["sentAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SignatureResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SignatureResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["envelopeId"] = this.envelopeId;
        data["status"] = this.status;
        data["signingUrl"] = this.signingUrl;
        data["sentAt"] = this.sentAt ? this.sentAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISignatureResponseDTO {
    envelopeId?: string;
    status?: string;
    signingUrl?: string;
    sentAt?: Date;

    [key: string]: any;
}

export class SendEmailRequestDTO implements ISendEmailRequestDTO {
    recipientEmail!: string;
    emailBody!: string;

    [key: string]: any;

    constructor(data?: ISendEmailRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.recipientEmail = _data["recipientEmail"];
            this.emailBody = _data["emailBody"];
        }
    }

    static fromJS(data: any): SendEmailRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["recipientEmail"] = this.recipientEmail;
        data["emailBody"] = this.emailBody;
        return data;
    }
}

export interface ISendEmailRequestDTO {
    recipientEmail: string;
    emailBody: string;

    [key: string]: any;
}

export class DocumentCreateRequest implements IDocumentCreateRequest {
    /** Document type: CONTRACT, ADDENDUM, BBA, COUNTER_EXHIBIT */
    type?: string;
    /** Document title */
    title!: string;
    /** Template ID to use for generating the document */
    templateId?: string;
    /** Data to populate the template (JSON object) */
    data?: JsonNode;
    docType?: string;

    [key: string]: any;

    constructor(data?: IDocumentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.templateId = _data["templateId"];
            this.data = _data["data"] ? JsonNode.fromJS(_data["data"]) : <any>undefined;
            this.docType = _data["docType"];
        }
    }

    static fromJS(data: any): DocumentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["templateId"] = this.templateId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["docType"] = this.docType;
        return data;
    }
}

export interface IDocumentCreateRequest {
    /** Document type: CONTRACT, ADDENDUM, BBA, COUNTER_EXHIBIT */
    type?: string;
    /** Document title */
    title: string;
    /** Template ID to use for generating the document */
    templateId?: string;
    /** Data to populate the template (JSON object) */
    data?: JsonNode;
    docType?: string;

    [key: string]: any;
}

export class DocumentDetailDto implements IDocumentDetailDto {
    /** Document ID */
    id?: string;
    /** Deal ID */
    dealId?: string;
    /** Document type */
    type?: string;
    /** Document title */
    title?: string;
    /** Document status */
    status?: string;
    /** PDF URL (preferred for large files) */
    pdfUrl?: string;
    /** PDF as base64 (for small files <1MB) */
    pdfBase64?: string;
    /** Creation timestamp (ISO format) */
    createdAtISO?: Date;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;
    /** S3 Storage URL */
    storageUrl?: string;
    /** Document type for table */
    docType?: string;
    /** Creator (Agent) identification */
    createdBy?: string;
    /** S3 path alias for storageUrl */
    storagePath?: string;
    /** Execution timestamp */
    signedAt?: Date;

    [key: string]: any;

    constructor(data?: IDocumentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.dealId = _data["dealId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.pdfUrl = _data["pdfUrl"];
            this.pdfBase64 = _data["pdfBase64"];
            this.createdAtISO = _data["createdAtISO"] ? new Date(_data["createdAtISO"].toString()) : <any>undefined;
            this.updatedAtISO = _data["updatedAtISO"] ? new Date(_data["updatedAtISO"].toString()) : <any>undefined;
            this.storageUrl = _data["storageUrl"];
            this.docType = _data["docType"];
            this.createdBy = _data["createdBy"];
            this.storagePath = _data["storagePath"];
            this.signedAt = _data["signedAt"] ? new Date(_data["signedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["dealId"] = this.dealId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["pdfUrl"] = this.pdfUrl;
        data["pdfBase64"] = this.pdfBase64;
        data["createdAtISO"] = this.createdAtISO ? this.createdAtISO.toISOString() : <any>undefined;
        data["updatedAtISO"] = this.updatedAtISO ? this.updatedAtISO.toISOString() : <any>undefined;
        data["storageUrl"] = this.storageUrl;
        data["docType"] = this.docType;
        data["createdBy"] = this.createdBy;
        data["storagePath"] = this.storagePath;
        data["signedAt"] = this.signedAt ? this.signedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDocumentDetailDto {
    /** Document ID */
    id?: string;
    /** Deal ID */
    dealId?: string;
    /** Document type */
    type?: string;
    /** Document title */
    title?: string;
    /** Document status */
    status?: string;
    /** PDF URL (preferred for large files) */
    pdfUrl?: string;
    /** PDF as base64 (for small files <1MB) */
    pdfBase64?: string;
    /** Creation timestamp (ISO format) */
    createdAtISO?: Date;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;
    /** S3 Storage URL */
    storageUrl?: string;
    /** Document type for table */
    docType?: string;
    /** Creator (Agent) identification */
    createdBy?: string;
    /** S3 path alias for storageUrl */
    storagePath?: string;
    /** Execution timestamp */
    signedAt?: Date;

    [key: string]: any;
}

export class DealCreateRequest implements IDealCreateRequest {
    /** Address line */
    addressLine!: string;
    /** Full address */
    fullAddress!: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Jurisdiction code */
    jurisdiction!: string;

    [key: string]: any;

    constructor(data?: IDealCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.addressLine = _data["addressLine"];
            this.fullAddress = _data["fullAddress"];
            this.buyerName = _data["buyerName"];
            this.sellerName = _data["sellerName"];
            this.mlsId = _data["mlsId"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): DealCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["addressLine"] = this.addressLine;
        data["fullAddress"] = this.fullAddress;
        data["buyerName"] = this.buyerName;
        data["sellerName"] = this.sellerName;
        data["mlsId"] = this.mlsId;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

export interface IDealCreateRequest {
    /** Address line */
    addressLine: string;
    /** Full address */
    fullAddress: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Jurisdiction code */
    jurisdiction: string;

    [key: string]: any;
}

export class GuestLinkCreateRequest implements IGuestLinkCreateRequest {
    /** Guest email address */
    guestEmail!: string;
    /** Guest name */
    guestName?: string;
    /** Link expiration in hours (default 72) */
    expirationHours?: number;

    [key: string]: any;

    constructor(data?: IGuestLinkCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.guestEmail = _data["guestEmail"];
            this.guestName = _data["guestName"];
            this.expirationHours = _data["expirationHours"];
        }
    }

    static fromJS(data: any): GuestLinkCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GuestLinkCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["guestEmail"] = this.guestEmail;
        data["guestName"] = this.guestName;
        data["expirationHours"] = this.expirationHours;
        return data;
    }
}

export interface IGuestLinkCreateRequest {
    /** Guest email address */
    guestEmail: string;
    /** Guest name */
    guestName?: string;
    /** Link expiration in hours (default 72) */
    expirationHours?: number;

    [key: string]: any;
}

export class BbaSearchRequest implements IBbaSearchRequest {
    buyerNames!: string;

    [key: string]: any;

    constructor(data?: IBbaSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.buyerNames = _data["buyerNames"];
        }
    }

    static fromJS(data: any): BbaSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BbaSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["buyerNames"] = this.buyerNames;
        return data;
    }
}

export interface IBbaSearchRequest {
    buyerNames: string;

    [key: string]: any;
}

export class BbaSearchResponse implements IBbaSearchResponse {
    fieldsJson?: JsonNode;
    found?: boolean;

    [key: string]: any;

    constructor(data?: IBbaSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fieldsJson = _data["fieldsJson"] ? JsonNode.fromJS(_data["fieldsJson"]) : <any>undefined;
            this.found = _data["found"];
        }
    }

    static fromJS(data: any): BbaSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BbaSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fieldsJson"] = this.fieldsJson ? this.fieldsJson.toJSON() : <any>undefined;
        data["found"] = this.found;
        return data;
    }
}

export interface IBbaSearchResponse {
    fieldsJson?: JsonNode;
    found?: boolean;

    [key: string]: any;
}

export class CounterOfferUpdateRequest implements ICounterOfferUpdateRequest {
    /** Updated fields JSON (only for DRAFT counters) */
    fieldsJson?: JsonNode;

    [key: string]: any;

    constructor(data?: ICounterOfferUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fieldsJson = _data["fieldsJson"] ? JsonNode.fromJS(_data["fieldsJson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CounterOfferUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CounterOfferUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fieldsJson"] = this.fieldsJson ? this.fieldsJson.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICounterOfferUpdateRequest {
    /** Updated fields JSON (only for DRAFT counters) */
    fieldsJson?: JsonNode;

    [key: string]: any;
}

export class ContractTemplateVersionDto implements IContractTemplateVersionDto {
    /** Unique ID of the Contract template */
    id?: string;
    /** Unique ID of the template version */
    versionId?: string;
    jurisdictionCode?: string;
    slug?: string;
    title?: string;
    documentPrompt?: string;
    pdfmeLayout?: JsonNode;
    /** Creation timestamp */
    createdAt?: Date;
    /** Voice agent prompt context */
    voiceAgentPrompt?: string;
    /** Extraction prompt for data extraction */
    extractionPrompt?: string;

    [key: string]: any;

    constructor(data?: IContractTemplateVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.versionId = _data["versionId"];
            this.jurisdictionCode = _data["jurisdictionCode"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.documentPrompt = _data["documentPrompt"];
            this.pdfmeLayout = _data["pdfmeLayout"] ? JsonNode.fromJS(_data["pdfmeLayout"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.voiceAgentPrompt = _data["voiceAgentPrompt"];
            this.extractionPrompt = _data["extractionPrompt"];
        }
    }

    static fromJS(data: any): ContractTemplateVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTemplateVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["versionId"] = this.versionId;
        data["jurisdictionCode"] = this.jurisdictionCode;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["documentPrompt"] = this.documentPrompt;
        data["pdfmeLayout"] = this.pdfmeLayout ? this.pdfmeLayout.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["voiceAgentPrompt"] = this.voiceAgentPrompt;
        data["extractionPrompt"] = this.extractionPrompt;
        return data;
    }
}

export interface IContractTemplateVersionDto {
    /** Unique ID of the Contract template */
    id?: string;
    /** Unique ID of the template version */
    versionId?: string;
    jurisdictionCode?: string;
    slug?: string;
    title?: string;
    documentPrompt?: string;
    pdfmeLayout?: JsonNode;
    /** Creation timestamp */
    createdAt?: Date;
    /** Voice agent prompt context */
    voiceAgentPrompt?: string;
    /** Extraction prompt for data extraction */
    extractionPrompt?: string;

    [key: string]: any;
}

export class TemplateListDto implements ITemplateListDto {
    /** Unique ID of the template */
    id?: string;
    /** Jurisdiction code */
    jurisdictionCode?: string;
    /** Template type */
    templateType?: TemplateListDtoTemplateType;
    /** Slug for ADDENDA templates */
    slug?: string;
    /** Template title */
    title?: string;
    /** Document prompt */
    documentPrompt?: string;
    /** Creation timestamp */
    createdAt?: Date;

    [key: string]: any;

    constructor(data?: ITemplateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.jurisdictionCode = _data["jurisdictionCode"];
            this.templateType = _data["templateType"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.documentPrompt = _data["documentPrompt"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TemplateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["jurisdictionCode"] = this.jurisdictionCode;
        data["templateType"] = this.templateType;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["documentPrompt"] = this.documentPrompt;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITemplateListDto {
    /** Unique ID of the template */
    id?: string;
    /** Jurisdiction code */
    jurisdictionCode?: string;
    /** Template type */
    templateType?: TemplateListDtoTemplateType;
    /** Slug for ADDENDA templates */
    slug?: string;
    /** Template title */
    title?: string;
    /** Document prompt */
    documentPrompt?: string;
    /** Creation timestamp */
    createdAt?: Date;

    [key: string]: any;
}

export class GuestContractViewDto implements IGuestContractViewDto {
    pdfmeLayout?: JsonNode;
    contractData?: JsonNode;

    [key: string]: any;

    constructor(data?: IGuestContractViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.pdfmeLayout = _data["pdfmeLayout"] ? JsonNode.fromJS(_data["pdfmeLayout"]) : <any>undefined;
            this.contractData = _data["contractData"] ? JsonNode.fromJS(_data["contractData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GuestContractViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuestContractViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pdfmeLayout"] = this.pdfmeLayout ? this.pdfmeLayout.toJSON() : <any>undefined;
        data["contractData"] = this.contractData ? this.contractData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGuestContractViewDto {
    pdfmeLayout?: JsonNode;
    contractData?: JsonNode;

    [key: string]: any;
}

export class ExtractionResponse implements IExtractionResponse {
    callId?: string;
    userId?: string;
    documentId?: string;
    contractInstanceId?: string;
    documentType?: string;
    status?: string;
    fieldsJson?: JsonNode;
    requiredFields?: { [key: string]: any; };
    createdAt?: string;
    updatedAt?: string;
    callStatus?: string;

    [key: string]: any;

    constructor(data?: IExtractionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.callId = _data["callId"];
            this.userId = _data["userId"];
            this.documentId = _data["documentId"];
            this.contractInstanceId = _data["contractInstanceId"];
            this.documentType = _data["documentType"];
            this.status = _data["status"];
            this.fieldsJson = _data["fieldsJson"] ? JsonNode.fromJS(_data["fieldsJson"]) : <any>undefined;
            if (_data["requiredFields"]) {
                this.requiredFields = {} as any;
                for (let key in _data["requiredFields"]) {
                    if (_data["requiredFields"].hasOwnProperty(key))
                        (<any>this.requiredFields)![key] = _data["requiredFields"][key];
                }
            }
            this.createdAt = _data["createdAt"];
            this.updatedAt = _data["updatedAt"];
            this.callStatus = _data["callStatus"];
        }
    }

    static fromJS(data: any): ExtractionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExtractionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["callId"] = this.callId;
        data["userId"] = this.userId;
        data["documentId"] = this.documentId;
        data["contractInstanceId"] = this.contractInstanceId;
        data["documentType"] = this.documentType;
        data["status"] = this.status;
        data["fieldsJson"] = this.fieldsJson ? this.fieldsJson.toJSON() : <any>undefined;
        if (this.requiredFields) {
            data["requiredFields"] = {};
            for (let key in this.requiredFields) {
                if (this.requiredFields.hasOwnProperty(key))
                    (<any>data["requiredFields"])[key] = (<any>this.requiredFields)[key];
            }
        }
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        data["callStatus"] = this.callStatus;
        return data;
    }
}

export interface IExtractionResponse {
    callId?: string;
    userId?: string;
    documentId?: string;
    contractInstanceId?: string;
    documentType?: string;
    status?: string;
    fieldsJson?: JsonNode;
    requiredFields?: { [key: string]: any; };
    createdAt?: string;
    updatedAt?: string;
    callStatus?: string;

    [key: string]: any;
}

export class DocumentListDto implements IDocumentListDto {
    /** Document ID */
    id?: string;
    /** Deal ID */
    dealId?: string;
    /** Document type */
    type?: string;
    /** Document title */
    title?: string;
    /** Document status */
    status?: string;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;
    /** Execution or Fallback timestamp */
    signedAt?: Date;

    [key: string]: any;

    constructor(data?: IDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.dealId = _data["dealId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.updatedAtISO = _data["updatedAtISO"] ? new Date(_data["updatedAtISO"].toString()) : <any>undefined;
            this.signedAt = _data["signedAt"] ? new Date(_data["signedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["dealId"] = this.dealId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["updatedAtISO"] = this.updatedAtISO ? this.updatedAtISO.toISOString() : <any>undefined;
        data["signedAt"] = this.signedAt ? this.signedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDocumentListDto {
    /** Document ID */
    id?: string;
    /** Deal ID */
    dealId?: string;
    /** Document type */
    type?: string;
    /** Document title */
    title?: string;
    /** Document status */
    status?: string;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;
    /** Execution or Fallback timestamp */
    signedAt?: Date;

    [key: string]: any;
}

export class ContractByJurisdictionDto implements IContractByJurisdictionDto {
    /** Contract document ID */
    contractId?: string;
    /** Property address from fields_json */
    address?: string;
    /** Document creation timestamp */
    createdAt?: Date;
    /** Buyer name from contract instance */
    buyerName?: string;

    [key: string]: any;

    constructor(data?: IContractByJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contractId = _data["contractId"];
            this.address = _data["address"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.buyerName = _data["buyerName"];
        }
    }

    static fromJS(data: any): ContractByJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractByJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contractId"] = this.contractId;
        data["address"] = this.address;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["buyerName"] = this.buyerName;
        return data;
    }
}

export interface IContractByJurisdictionDto {
    /** Contract document ID */
    contractId?: string;
    /** Property address from fields_json */
    address?: string;
    /** Document creation timestamp */
    createdAt?: Date;
    /** Buyer name from contract instance */
    buyerName?: string;

    [key: string]: any;
}

export class DealListDto implements IDealListDto {
    /** Deal ID */
    id?: string;
    /** Address line */
    addressLine?: string;
    /** City and state */
    cityState?: string;
    /** Deal status */
    status?: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;

    [key: string]: any;

    constructor(data?: IDealListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.addressLine = _data["addressLine"];
            this.cityState = _data["cityState"];
            this.status = _data["status"];
            this.buyerName = _data["buyerName"];
            this.sellerName = _data["sellerName"];
            this.mlsId = _data["mlsId"];
            this.updatedAtISO = _data["updatedAtISO"] ? new Date(_data["updatedAtISO"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DealListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["addressLine"] = this.addressLine;
        data["cityState"] = this.cityState;
        data["status"] = this.status;
        data["buyerName"] = this.buyerName;
        data["sellerName"] = this.sellerName;
        data["mlsId"] = this.mlsId;
        data["updatedAtISO"] = this.updatedAtISO ? this.updatedAtISO.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDealListDto {
    /** Deal ID */
    id?: string;
    /** Address line */
    addressLine?: string;
    /** City and state */
    cityState?: string;
    /** Deal status */
    status?: string;
    /** Buyer name */
    buyerName?: string;
    /** Seller name */
    sellerName?: string;
    /** MLS ID */
    mlsId?: string;
    /** Last update timestamp (ISO format) */
    updatedAtISO?: Date;

    [key: string]: any;
}

export class DealListResponseDto implements IDealListResponseDto {
    /** List of deals */
    items?: DealListDto[];
    /** Total number of deals */
    total?: number;
    /** Limit per page */
    limit?: number;
    /** Offset for pagination */
    offset?: number;

    [key: string]: any;

    constructor(data?: IDealListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DealListDto.fromJS(item));
            }
            this.total = _data["total"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): DealListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IDealListResponseDto {
    /** List of deals */
    items?: DealListDto[];
    /** Total number of deals */
    total?: number;
    /** Limit per page */
    limit?: number;
    /** Offset for pagination */
    offset?: number;

    [key: string]: any;
}

export class AddendumItemDto implements IAddendumItemDto {
    /** Addendum document title */
    title?: string;
    /** Document type (e.g. ADDENDUM, ADDENDA) */
    type?: string;
    /** URL to the executed or stored PDF, if available */
    url?: string;

    [key: string]: any;

    constructor(data?: IAddendumItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): AddendumItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddendumItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }
}

export interface IAddendumItemDto {
    /** Addendum document title */
    title?: string;
    /** Document type (e.g. ADDENDUM, ADDENDA) */
    type?: string;
    /** URL to the executed or stored PDF, if available */
    url?: string;

    [key: string]: any;
}

export class Body implements IBody {
    file!: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

export interface IBody {
    file: string;

    [key: string]: any;
}

export class Body2 implements IBody2 {
    file!: string;

    [key: string]: any;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

export interface IBody2 {
    file: string;

    [key: string]: any;
}

export enum Status {
    DRAFT = "DRAFT",
    PUBLISHED = "PUBLISHED",
    DEPRECATED = "DEPRECATED",
}

export enum Status2 {
    DRAFT = "DRAFT",
    PUBLISHED = "PUBLISHED",
    DEPRECATED = "DEPRECATED",
}

export enum Status3 {
    DRAFT = "DRAFT",
    PUBLISHED = "PUBLISHED",
    DEPRECATED = "DEPRECATED",
}

export enum TemplateType {
    ADDENDA = "ADDENDA",
    ADDENDUM = "ADDENDUM",
    CONTRACT = "CONTRACT",
    COUNTEROFFERS = "COUNTEROFFERS",
    COUNTER_EXHIBIT = "COUNTER_EXHIBIT",
    BBA = "BBA",
}

export enum Status4 {
    DRAFT = "DRAFT",
    PUBLISHED = "PUBLISHED",
    DEPRECATED = "DEPRECATED",
}

export enum TemplateType2 {
    ADDENDA = "ADDENDA",
    ADDENDUM = "ADDENDUM",
    CONTRACT = "CONTRACT",
    COUNTEROFFERS = "COUNTEROFFERS",
    COUNTER_EXHIBIT = "COUNTER_EXHIBIT",
    BBA = "BBA",
}

export enum UserResponseDTORole {
    ADMIN = "ADMIN",
    AGENT = "AGENT",
}

export enum UserResponseDTOStatus {
    ACTIVE = "ACTIVE",
    PENDING = "PENDING",
    BANNED = "BANNED",
    DEACTIVATED = "DEACTIVATED",
}

export enum ContractTemplateCreateRequestTemplateType {
    ADDENDA = "ADDENDA",
    ADDENDUM = "ADDENDUM",
    CONTRACT = "CONTRACT",
    COUNTEROFFERS = "COUNTEROFFERS",
    COUNTER_EXHIBIT = "COUNTER_EXHIBIT",
    BBA = "BBA",
}

export enum TemplateListDtoTemplateType {
    ADDENDA = "ADDENDA",
    ADDENDUM = "ADDENDUM",
    CONTRACT = "CONTRACT",
    COUNTEROFFERS = "COUNTEROFFERS",
    COUNTER_EXHIBIT = "COUNTER_EXHIBIT",
    BBA = "BBA",
}
//-----/CustomTypes.File-----

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

//-----/Types.File-----

import { addResultTypeFactory } from './fetch-client/helpers';
export { setBaseUrl, getBaseUrl } from './fetch-client/helpers';
export { setFetchFactory, getFetch } from './fetch-client/helpers';


//-----PersistorHydrator.File-----
import type { PersistedClient } from '@tanstack/react-query-persist-client';
import type { DehydratedState, QueryKey } from '@tanstack/react-query'
import { getResultTypeFactory } from './fetch-client/helpers';

/*
 * If you have Dates in QueryKeys (i.e. in request parameters), you need to deserialize them to Dates correctly
 * (otherwise they are deserialized as strings by default, and your queries are broken).
 */
export function deserializeDate(str: unknown) {
  if (!str || typeof str !== 'string') return str;
  if (!/^\d\d\d\d\-\d\d\-\d\d/.test(str)) return str;
  
  const date = new Date(str);
  const isDate = date instanceof Date && !isNaN(date as any);
  
  return isDate ? date : str;
}

export function deserializeDatesInQueryKeys(queryKey: QueryKey) {
  return queryKey
    // We need to replace `null` with `undefined` in query key, because
    // `undefined` is serialized as `null`.
    // And most probably if we have `null` in QueryKey it actually means `undefined`.
    // We can't keep nulls, because they have a different meaning, and e.g. boolean parameters are not allowed to be null.
    .map(x => (x === null ? undefined : x))
    .map(x => deserializeDate(x));
}

export function deserializeClassesInQueryData(queryKey: QueryKey, data: any) {
  if (!data) {
    return data;
  } else if (typeof data !== 'object') {
    return data;
  } else if ('pages' in data && 'pageParams' in data && Array.isArray(data.pages) && Array.isArray(data.pageParams)) {
    // infinite query
    data.pages = data.pages.map((page:any) => deserializeClassesInQueryData(queryKey, page));
  } else if (Array.isArray(data)) {
    return data.map(elem => constructDtoClass(queryKey, elem));
  } else {
    return constructDtoClass(queryKey, data);
  }
}

/*
 * Pass this function as `deserialize` option to createSyncStoragePersister/createAsyncStoragePersister
 * to correctly deserialize your DTOs (including Dates)
 */
export function persisterDeserialize(cache: string): PersistedClient {
  const client: PersistedClient = JSON.parse(cache);
  client.clientState.queries.forEach((query) => {
    query.state.data = deserializeClassesInQueryData(query.queryKey, query.state.data);
    query.queryKey = deserializeDatesInQueryKeys(query.queryKey);
  });

  return client;
}

export function constructDtoClass(queryKey: QueryKey, data: any): unknown {
  const resultTypeKey = getResultTypeClassKey(queryKey);
  const constructorFunction = getResultTypeFactory(resultTypeKey);

  if (!data || !constructorFunction)
    return data;

  return constructorFunction(data);
}

export function getResultTypeClassKey(queryKey: QueryKey): string {
  if (!Array.isArray(queryKey)) {
    return queryKey as unknown as string;
  }
  if (queryKey.length >= 2) {
    // We concatenate first and second elements, because they uniquely identify the query.
    // All other QueryKey elements are query parameters
    return `${queryKey[0]}___${queryKey[1]}`;
  }

  // We actually should never reach this point :)
  return queryKey.join('___');
}

export function initPersister() {
  
  addResultTypeFactory('Client___getCurrentUserProfile', (data: any) => { const result = new UserResponseDTO(); result.init(data); return result; });
  addResultTypeFactory('Client___getJurisdictionById', (data: any) => { const result = new JurisdictionResponseDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getDeal', (data: any) => { const result = new DealDetailDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getAllJurisdictions', (data: any) => { const result = new JurisdictionResponseDto(); result.init(data); return result; });
  addResultTypeFactory('Client___listGuestCounterOffers', (data: any) => { const result = new CounterOfferDto(); result.init(data); return result; });
  addResultTypeFactory('Client___listDocuments', (data: any) => { const result = new DocumentListDto(); result.init(data); return result; });
  addResultTypeFactory('Client___listDeals', (data: any) => { const result = new DealListResponseDto(); result.init(data); return result; });
  addResultTypeFactory('Client___listGuestLinks', (data: any) => { const result = new GuestLinkDto(); result.init(data); return result; });
  addResultTypeFactory('Client___listCounterOffers', (data: any) => { const result = new CounterOfferDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getCounterOffer', (data: any) => { const result = new CounterOfferDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getTemplateVersionById', (data: any) => { const result = new ContractTemplateVersionDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getTemplatePdfmeLayout', (data: any) => { const result = new PdfmeLayoutUpdateRequest(); result.init(data); return result; });
  addResultTypeFactory('Client___getAllTemplateVersions', (data: any) => { const result = new ContractTemplateVersionDto(); result.init(data); return result; });
  addResultTypeFactory('Client___findOrCreateTemplate', (data: any) => { const result = new ContractTemplateVersionDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getAddendumPdfmeLayout', (data: any) => { const result = new PdfmeLayoutUpdateRequest(); result.init(data); return result; });
  addResultTypeFactory('Client___getTemplates', (data: any) => { const result = new TemplateListDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getGuestCounterOffer', (data: any) => { const result = new CounterOfferDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getGuestContractView', (data: any) => { const result = new GuestContractViewDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getExtractions', (data: any) => { const result = new ExtractionResponse(); result.init(data); return result; });
  addResultTypeFactory('Client___listAllDocuments', (data: any) => { const result = new DocumentListDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getDocument', (data: any) => { const result = new DocumentDetailDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getContractsByAgent', (data: any) => { const result = new ContractByJurisdictionDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getAddenda', (data: any) => { const result = new AddendumItemDto(); result.init(data); return result; });
  addResultTypeFactory('Client___getSignedDocuments', (data: any) => { const result = new DocumentDetailDto(); result.init(data); return result; });


}
//-----/PersistorHydrator.File----